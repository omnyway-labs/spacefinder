["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/i18n/numberformat.js"],"~:js","goog.provide(\"goog.i18n.NumberFormat\");\ngoog.provide(\"goog.i18n.NumberFormat.CurrencyStyle\");\ngoog.provide(\"goog.i18n.NumberFormat.Format\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.i18n.CompactNumberFormatSymbols\");\ngoog.require(\"goog.i18n.NumberFormatSymbols\");\ngoog.require(\"goog.i18n.NumberFormatSymbols_u_nu_latn\");\ngoog.require(\"goog.i18n.currency\");\ngoog.require(\"goog.math\");\ngoog.require(\"goog.string\");\n/**\n * @constructor\n * @param {(number|string)} pattern\n * @param {string=} opt_currency\n * @param {number=} opt_currencyStyle\n * @param {!Object<string,string>=} opt_symbols\n */\ngoog.i18n.NumberFormat = function(pattern, opt_currency, opt_currencyStyle, opt_symbols) {\n  /** @private @const @type {?string} */ this.intlCurrencyCode_ = opt_currency || null;\n  /** @private @const @type {number} */ this.currencyStyle_ = opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;\n  /** @private @const @type {?Object<string,string>} */ this.overrideNumberFormatSymbols_ = opt_symbols || null;\n  /** @private @type {number} */ this.maximumIntegerDigits_ = 40;\n  /** @private @type {number} */ this.minimumIntegerDigits_ = 1;\n  /** @private @type {number} */ this.significantDigits_ = 0;\n  /** @private @type {number} */ this.maximumFractionDigits_ = 3;\n  /** @private @type {number} */ this.minimumFractionDigits_ = 0;\n  /** @private @type {number} */ this.minExponentDigits_ = 0;\n  /** @private @type {boolean} */ this.useSignForPositiveExponent_ = false;\n  /** @private @type {boolean} */ this.showTrailingZeros_ = false;\n  /** @private @type {string} */ this.positivePrefix_ = \"\";\n  /** @private @type {string} */ this.positiveSuffix_ = \"\";\n  /** @private @type {string} */ this.negativePrefix_ = this.getNumberFormatSymbols_().MINUS_SIGN;\n  /** @private @type {string} */ this.negativeSuffix_ = \"\";\n  /** @private @type {number} */ this.multiplier_ = 1;\n  /** @private @type {boolean} */ this.negativePercentSignExpected_ = false;\n  /** @private @type {!Array<number>} */ this.groupingArray_ = [];\n  /** @private @type {boolean} */ this.decimalSeparatorAlwaysShown_ = false;\n  /** @private @type {boolean} */ this.useExponentialNotation_ = false;\n  /** @private @type {goog.i18n.NumberFormat.CompactStyle} */ this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;\n  /** @private @type {?number} */ this.baseFormattingNumber_ = null;\n  /** @private @type {string} */ this.pattern_;\n  if (typeof pattern == \"number\") {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n/** @enum {number} */ goog.i18n.NumberFormat.Format = {DECIMAL:1, SCIENTIFIC:2, PERCENT:3, CURRENCY:4, COMPACT_SHORT:5, COMPACT_LONG:6};\n/** @enum {number} */ goog.i18n.NumberFormat.CurrencyStyle = {LOCAL:0, PORTABLE:1, GLOBAL:2};\n/** @enum {number} */ goog.i18n.NumberFormat.CompactStyle = {NONE:0, SHORT:1, LONG:2};\n/** @private @type {boolean} */ goog.i18n.NumberFormat.enforceAsciiDigits_ = false;\n/**\n * @param {boolean} doEnforce\n */\ngoog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {\n  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;\n};\n/**\n * @return {boolean}\n */\ngoog.i18n.NumberFormat.isEnforceAsciiDigits = function() {\n  return goog.i18n.NumberFormat.enforceAsciiDigits_;\n};\n/**\n * @private\n * @return {!Object}\n */\ngoog.i18n.NumberFormat.prototype.getNumberFormatSymbols_ = function() {\n  return this.overrideNumberFormatSymbols_ || (goog.i18n.NumberFormat.enforceAsciiDigits_ ? goog.i18n.NumberFormatSymbols_u_nu_latn : goog.i18n.NumberFormatSymbols);\n};\n/**\n * @private\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {\n  return this.intlCurrencyCode_ || this.getNumberFormatSymbols_().DEF_CURRENCY_CODE;\n};\n/**\n * @param {number} min\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {\n  if (this.significantDigits_ > 0 && min > 0) {\n    throw new Error(\"Can't combine significant digits and minimum fraction digits\");\n  }\n  this.minimumFractionDigits_ = min;\n  return this;\n};\n/**\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getMinimumFractionDigits = function() {\n  return this.minimumFractionDigits_;\n};\n/**\n * @param {number} max\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {\n  if (max > 308) {\n    throw new Error(\"Unsupported maximum fraction digits: \" + max);\n  }\n  this.maximumFractionDigits_ = max;\n  return this;\n};\n/**\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getMaximumFractionDigits = function() {\n  return this.maximumFractionDigits_;\n};\n/**\n * @param {number} number\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {\n  if (this.minimumFractionDigits_ > 0 && number >= 0) {\n    throw new Error(\"Can't combine significant digits and minimum fraction digits\");\n  }\n  this.significantDigits_ = number;\n  return this;\n};\n/**\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getSignificantDigits = function() {\n  return this.significantDigits_;\n};\n/**\n * @param {boolean} showTrailingZeros\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(showTrailingZeros) {\n  this.showTrailingZeros_ = showTrailingZeros;\n  return this;\n};\n/**\n * @param {?number} baseFormattingNumber\n * @return {!goog.i18n.NumberFormat}\n */\ngoog.i18n.NumberFormat.prototype.setBaseFormatting = function(baseFormattingNumber) {\n  goog.asserts.assert(goog.isNull(baseFormattingNumber) || isFinite(baseFormattingNumber));\n  this.baseFormattingNumber_ = baseFormattingNumber;\n  return this;\n};\n/**\n * @return {?number}\n */\ngoog.i18n.NumberFormat.prototype.getBaseFormatting = function() {\n  return this.baseFormattingNumber_;\n};\n/**\n * @private\n * @param {string} pattern\n */\ngoog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {\n  this.pattern_ = pattern.replace(/ /g, \" \");\n  var pos = [0];\n  this.positivePrefix_ = this.parseAffix_(pattern, pos);\n  var trunkStart = pos[0];\n  this.parseTrunk_(pattern, pos);\n  var trunkLen = pos[0] - trunkStart;\n  this.positiveSuffix_ = this.parseAffix_(pattern, pos);\n  if (pos[0] < pattern.length && pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {\n    pos[0]++;\n    if (this.multiplier_ != 1) {\n      this.negativePercentSignExpected_ = true;\n    }\n    this.negativePrefix_ = this.parseAffix_(pattern, pos);\n    pos[0] += trunkLen;\n    this.negativeSuffix_ = this.parseAffix_(pattern, pos);\n  } else {\n    this.negativePrefix_ += this.positivePrefix_;\n    this.negativeSuffix_ += this.positiveSuffix_;\n  }\n};\n/**\n * @private\n * @param {number} patternType\n */\ngoog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {\n  switch(patternType) {\n    case goog.i18n.NumberFormat.Format.DECIMAL:\n      this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.SCIENTIFIC:\n      this.applyPattern_(this.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.PERCENT:\n      this.applyPattern_(this.getNumberFormatSymbols_().PERCENT_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.CURRENCY:\n      this.applyPattern_(goog.i18n.currency.adjustPrecision(this.getNumberFormatSymbols_().CURRENCY_PATTERN, this.getCurrencyCode_()));\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_LONG:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);\n      break;\n    default:\n      throw new Error(\"Unsupported pattern type.\");\n  }\n};\n/**\n * @private\n * @param {goog.i18n.NumberFormat.CompactStyle} style\n */\ngoog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {\n  this.compactStyle_ = style;\n  this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);\n  this.setMinimumFractionDigits(0);\n  this.setMaximumFractionDigits(2);\n  this.setSignificantDigits(2);\n};\n/**\n * @param {string} text\n * @param {Array<number>=} opt_pos\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {\n  var pos = opt_pos || [0];\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw new Error(\"Parsing of compact numbers is unimplemented\");\n  }\n  var ret = NaN;\n  text = text.replace(/ |\\u202f/g, \" \");\n  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];\n  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];\n  if (gotPositive && gotNegative) {\n    if (this.positivePrefix_.length > this.negativePrefix_.length) {\n      gotNegative = false;\n    } else {\n      if (this.positivePrefix_.length < this.negativePrefix_.length) {\n        gotPositive = false;\n      }\n    }\n  }\n  if (gotPositive) {\n    pos[0] += this.positivePrefix_.length;\n  } else {\n    if (gotNegative) {\n      pos[0] += this.negativePrefix_.length;\n    }\n  }\n  if (text.indexOf(this.getNumberFormatSymbols_().INFINITY, pos[0]) == pos[0]) {\n    pos[0] += this.getNumberFormatSymbols_().INFINITY.length;\n    ret = Infinity;\n  } else {\n    ret = this.parseNumber_(text, pos);\n  }\n  if (gotPositive) {\n    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {\n      return NaN;\n    }\n    pos[0] += this.positiveSuffix_.length;\n  } else {\n    if (gotNegative) {\n      if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {\n        return NaN;\n      }\n      pos[0] += this.negativeSuffix_.length;\n    }\n  }\n  return gotNegative ? -ret : ret;\n};\n/**\n * @private\n * @param {string} text\n * @param {Array<number>} pos\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {\n  var sawDecimal = false;\n  var sawExponent = false;\n  var sawDigit = false;\n  var exponentPos = -1;\n  var scale = 1;\n  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\n  var exponentChar = this.getNumberFormatSymbols_().EXP_SYMBOL;\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw new Error(\"Parsing of compact style numbers is not implemented\");\n  }\n  grouping = grouping.replace(/\\u202f/g, \" \");\n  var normalizedText = \"\";\n  for (; pos[0] < text.length; pos[0]++) {\n    var ch = text.charAt(pos[0]);\n    var digit = this.getDigit_(ch);\n    if (digit >= 0 && digit <= 9) {\n      normalizedText += digit;\n      sawDigit = true;\n    } else {\n      if (ch == decimal.charAt(0)) {\n        if (sawDecimal || sawExponent) {\n          break;\n        }\n        normalizedText += \".\";\n        sawDecimal = true;\n      } else {\n        if (ch == grouping.charAt(0) && (\" \" != grouping.charAt(0) || pos[0] + 1 < text.length && this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {\n          if (sawDecimal || sawExponent) {\n            break;\n          }\n          continue;\n        } else {\n          if (ch == exponentChar.charAt(0)) {\n            if (sawExponent) {\n              break;\n            }\n            normalizedText += \"E\";\n            sawExponent = true;\n            exponentPos = pos[0];\n          } else {\n            if (ch == \"+\" || ch == \"-\") {\n              if (sawDigit && exponentPos != pos[0] - 1) {\n                break;\n              }\n              normalizedText += ch;\n            } else {\n              if (this.multiplier_ == 1 && ch == this.getNumberFormatSymbols_().PERCENT.charAt(0)) {\n                if (scale != 1) {\n                  break;\n                }\n                scale = 100;\n                if (sawDigit) {\n                  pos[0]++;\n                  break;\n                }\n              } else {\n                if (this.multiplier_ == 1 && ch == this.getNumberFormatSymbols_().PERMILL.charAt(0)) {\n                  if (scale != 1) {\n                    break;\n                  }\n                  scale = 1000;\n                  if (sawDigit) {\n                    pos[0]++;\n                    break;\n                  }\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (this.multiplier_ != 1) {\n    scale = this.multiplier_;\n  }\n  return parseFloat(normalizedText) / scale;\n};\n/**\n * @param {number} number\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.format = function(number) {\n  if (isNaN(number)) {\n    return this.getNumberFormatSymbols_().NAN;\n  }\n  var parts = [];\n  var baseFormattingNumber = goog.isNull(this.baseFormattingNumber_) ? number : this.baseFormattingNumber_;\n  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);\n  number = goog.i18n.NumberFormat.decimalShift_(number, -unit.divisorBase);\n  parts.push(unit.prefix);\n  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;\n  parts.push(isNegative ? this.negativePrefix_ : this.positivePrefix_);\n  if (!isFinite(number)) {\n    parts.push(this.getNumberFormatSymbols_().INFINITY);\n  } else {\n    number *= isNegative ? -1 : 1;\n    number *= this.multiplier_;\n    this.useExponentialNotation_ ? this.subformatExponential_(number, parts) : this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n  }\n  parts.push(isNegative ? this.negativeSuffix_ : this.positiveSuffix_);\n  parts.push(unit.suffix);\n  return parts.join(\"\");\n};\n/**\n * @private\n * @param {number} number\n * @return {{intValue:number,fracValue:number}}\n */\ngoog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {\n  var shift = goog.i18n.NumberFormat.decimalShift_;\n  var shiftedNumber = shift(number, this.maximumFractionDigits_);\n  if (this.significantDigits_ > 0) {\n    shiftedNumber = this.roundToSignificantDigits_(shiftedNumber, this.significantDigits_, this.maximumFractionDigits_);\n  }\n  shiftedNumber = Math.round(shiftedNumber);\n  var intValue, fracValue;\n  if (isFinite(shiftedNumber)) {\n    intValue = Math.floor(shift(shiftedNumber, -this.maximumFractionDigits_));\n    fracValue = Math.floor(shiftedNumber - shift(intValue, this.maximumFractionDigits_));\n  } else {\n    intValue = number;\n    fracValue = 0;\n  }\n  return {intValue:intValue, fracValue:fracValue};\n};\n/**\n * @private\n * @param {!Array<string>} parts\n * @param {number} zeroCode\n * @param {string} intPart\n * @param {!Array<number>} groupingArray\n * @param {number} repeatedDigitLen\n * @return {!Array<string>}\n */\ngoog.i18n.NumberFormat.prototype.formatNumberGroupingRepeatingDigitsParts_ = function(parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {\n  var nonRepeatedGroupCompleteCount = 0;\n  var currentGroupSizeIndex = 0;\n  var currentGroupSize = 0;\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\n  var digitLen = intPart.length;\n  for (var i = 0; i < digitLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));\n    if (digitLen - i > 1) {\n      currentGroupSize = groupingArray[currentGroupSizeIndex];\n      if (i < repeatedDigitLen) {\n        var repeatedDigitIndex = repeatedDigitLen - i;\n        if (currentGroupSize === 1 || currentGroupSize > 0 && repeatedDigitIndex % currentGroupSize === 1) {\n          parts.push(grouping);\n        }\n      } else {\n        if (currentGroupSizeIndex < groupingArray.length) {\n          if (i === repeatedDigitLen) {\n            currentGroupSizeIndex += 1;\n          } else {\n            if (currentGroupSize === i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {\n              parts.push(grouping);\n              nonRepeatedGroupCompleteCount += currentGroupSize;\n              currentGroupSizeIndex += 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return parts;\n};\n/**\n * @private\n * @param {!Array<string>} parts\n * @param {number} zeroCode\n * @param {string} intPart\n * @param {!Array<number>} groupingArray\n * @return {!Array<string>}\n */\ngoog.i18n.NumberFormat.prototype.formatNumberGroupingNonRepeatingDigitsParts_ = function(parts, zeroCode, intPart, groupingArray) {\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\n  var currentGroupSizeIndex;\n  var currentGroupSize = 0;\n  var digitLenLeft = intPart.length;\n  var rightToLeftParts = [];\n  for (currentGroupSizeIndex = groupingArray.length - 1; currentGroupSizeIndex >= 0 && digitLenLeft > 0; currentGroupSizeIndex--) {\n    currentGroupSize = groupingArray[currentGroupSizeIndex];\n    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize && digitLenLeft - rightDigitIndex - 1 >= 0; rightDigitIndex++) {\n      rightToLeftParts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));\n    }\n    digitLenLeft -= currentGroupSize;\n    if (digitLenLeft > 0) {\n      rightToLeftParts.push(grouping);\n    }\n  }\n  parts.push.apply(parts, rightToLeftParts.reverse());\n  return parts;\n};\n/**\n * @private\n * @param {number} number\n * @param {number} minIntDigits\n * @param {Array<string>} parts\n */\ngoog.i18n.NumberFormat.prototype.subformatFixed_ = function(number, minIntDigits, parts) {\n  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {\n    throw new Error(\"Min value must be less than max value\");\n  }\n  if (!parts) {\n    parts = [];\n  }\n  var rounded = this.roundNumber_(number);\n  var intValue = rounded.intValue;\n  var fracValue = rounded.fracValue;\n  var numIntDigits = intValue == 0 ? 0 : this.intLog10_(intValue) + 1;\n  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 || this.showTrailingZeros_ && numIntDigits < this.significantDigits_;\n  var minimumFractionDigits = this.minimumFractionDigits_;\n  if (fractionPresent) {\n    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {\n      minimumFractionDigits = this.significantDigits_ - numIntDigits;\n    } else {\n      minimumFractionDigits = this.minimumFractionDigits_;\n    }\n  }\n  var intPart = \"\";\n  var translatableInt = intValue;\n  while (translatableInt > 1E20) {\n    intPart = \"0\" + intPart;\n    translatableInt = Math.round(goog.i18n.NumberFormat.decimalShift_(translatableInt, -1));\n  }\n  intPart = translatableInt + intPart;\n  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;\n  var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n  var digitLen = intPart.length;\n  var nonRepeatedGroupCount = 0;\n  if (intValue > 0 || minIntDigits > 0) {\n    for (var i = digitLen; i < minIntDigits; i++) {\n      parts.push(String.fromCharCode(zeroCode));\n    }\n    if (this.groupingArray_.length >= 2) {\n      for (var j = 1; j < this.groupingArray_.length; j++) {\n        nonRepeatedGroupCount += this.groupingArray_[j];\n      }\n    }\n    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;\n    if (repeatedDigitLen > 0) {\n      parts = this.formatNumberGroupingRepeatingDigitsParts_(parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);\n    } else {\n      parts = this.formatNumberGroupingNonRepeatingDigitsParts_(parts, zeroCode, intPart, this.groupingArray_);\n    }\n  } else {\n    if (!fractionPresent) {\n      parts.push(String.fromCharCode(zeroCode));\n    }\n  }\n  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {\n    parts.push(decimal);\n  }\n  var fracPart = String(fracValue);\n  var fracPartSplit = fracPart.split(\"e+\");\n  if (fracPartSplit.length == 2) {\n    var floatFrac = parseFloat(fracPartSplit[0]);\n    fracPart = String(this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));\n    fracPart = fracPart.replace(\".\", \"\");\n    var exp = parseInt(fracPartSplit[1], 10);\n    fracPart += goog.string.repeat(\"0\", exp - fracPart.length + 1);\n  }\n  if (this.maximumFractionDigits_ + 1 > fracPart.length) {\n    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;\n    fracPart = \"1\" + goog.string.repeat(\"0\", zeroesToAdd) + fracPart;\n  }\n  var fracLen = fracPart.length;\n  while (fracPart.charAt(fracLen - 1) == \"0\" && fracLen > minimumFractionDigits + 1) {\n    fracLen--;\n  }\n  for (var i = 1; i < fracLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));\n  }\n};\n/**\n * @private\n * @param {number} exponent\n * @param {Array<string>} parts\n */\ngoog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {\n  parts.push(this.getNumberFormatSymbols_().EXP_SYMBOL);\n  if (exponent < 0) {\n    exponent = -exponent;\n    parts.push(this.getNumberFormatSymbols_().MINUS_SIGN);\n  } else {\n    if (this.useSignForPositiveExponent_) {\n      parts.push(this.getNumberFormatSymbols_().PLUS_SIGN);\n    }\n  }\n  var exponentDigits = \"\" + exponent;\n  var zeroChar = this.getNumberFormatSymbols_().ZERO_DIGIT;\n  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {\n    parts.push(zeroChar);\n  }\n  parts.push(exponentDigits);\n};\n/**\n * @private\n * @param {number} value\n * @param {number} exponent\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {\n  return goog.i18n.NumberFormat.decimalShift_(value, -exponent);\n};\n/**\n * @private\n * @param {number} number\n * @param {Array<string>} parts\n */\ngoog.i18n.NumberFormat.prototype.subformatExponential_ = function(number, parts) {\n  if (number == 0.0) {\n    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n    this.addExponentPart_(0, parts);\n    return;\n  }\n  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));\n  number = this.getMantissa_(number, exponent);\n  var minIntDigits = this.minimumIntegerDigits_;\n  if (this.maximumIntegerDigits_ > 1 && this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {\n    var remainder = exponent % this.maximumIntegerDigits_;\n    if (remainder < 0) {\n      remainder = this.maximumIntegerDigits_ + remainder;\n    }\n    number = goog.i18n.NumberFormat.decimalShift_(number, remainder);\n    exponent -= remainder;\n    minIntDigits = 1;\n  } else {\n    if (this.minimumIntegerDigits_ < 1) {\n      exponent++;\n      number = goog.i18n.NumberFormat.decimalShift_(number, -1);\n    } else {\n      exponent -= this.minimumIntegerDigits_ - 1;\n      number = goog.i18n.NumberFormat.decimalShift_(number, this.minimumIntegerDigits_ - 1);\n    }\n  }\n  this.subformatFixed_(number, minIntDigits, parts);\n  this.addExponentPart_(exponent, parts);\n};\n/**\n * @private\n * @param {string} ch\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {\n  var code = ch.charCodeAt(0);\n  if (48 <= code && code < 58) {\n    return code - 48;\n  } else {\n    var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;\n  }\n};\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = \"0\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = \",\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = \".\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_PER_MILLE_ = \"‰\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_PERCENT_ = \"%\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_DIGIT_ = \"#\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_SEPARATOR_ = \";\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_EXPONENT_ = \"E\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_PLUS_ = \"+\";\n/** @private @type {string} */ goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = \"¤\";\n/** @private @type {string} */ goog.i18n.NumberFormat.QUOTE_ = \"'\";\n/**\n * @private\n * @param {string} pattern\n * @param {Array<number>} pos\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {\n  var affix = \"\";\n  var inQuote = false;\n  var len = pattern.length;\n  for (; pos[0] < len; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    if (ch == goog.i18n.NumberFormat.QUOTE_) {\n      if (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {\n        pos[0]++;\n        affix += \"'\";\n      } else {\n        inQuote = !inQuote;\n      }\n      continue;\n    }\n    if (inQuote) {\n      affix += ch;\n    } else {\n      switch(ch) {\n        case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:\n          return affix;\n        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:\n          if (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {\n            pos[0]++;\n            affix += this.getCurrencyCode_();\n          } else {\n            switch(this.currencyStyle_) {\n              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:\n                affix += goog.i18n.currency.getLocalCurrencySign(this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:\n                affix += goog.i18n.currency.getGlobalCurrencySign(this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:\n                affix += goog.i18n.currency.getPortableCurrencySign(this.getCurrencyCode_());\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PERCENT_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw new Error(\"Too many percent/permill\");\n          } else {\n            if (this.negativePercentSignExpected_ && this.multiplier_ != 100) {\n              throw new Error(\"Inconsistent use of percent/permill characters\");\n            }\n          }\n          this.multiplier_ = 100;\n          this.negativePercentSignExpected_ = false;\n          affix += this.getNumberFormatSymbols_().PERCENT;\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw new Error(\"Too many percent/permill\");\n          } else {\n            if (this.negativePercentSignExpected_ && this.multiplier_ != 1000) {\n              throw new Error(\"Inconsistent use of percent/permill characters\");\n            }\n          }\n          this.multiplier_ = 1000;\n          this.negativePercentSignExpected_ = false;\n          affix += this.getNumberFormatSymbols_().PERMILL;\n          break;\n        default:\n          affix += ch;\n      }\n    }\n  }\n  return affix;\n};\n/**\n * @private\n * @param {string} pattern\n * @param {Array<number>} pos\n */\ngoog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {\n  var decimalPos = -1;\n  var digitLeftCount = 0;\n  var zeroDigitCount = 0;\n  var digitRightCount = 0;\n  var groupingCount = -1;\n  var len = pattern.length;\n  for (var loop = true; pos[0] < len && loop; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    switch(ch) {\n      case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        if (zeroDigitCount > 0) {\n          digitRightCount++;\n        } else {\n          digitLeftCount++;\n        }\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        if (digitRightCount > 0) {\n          throw new Error('Unexpected \"0\" in pattern \"' + pattern + '\"');\n        }\n        zeroDigitCount++;\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        if (groupingCount > 0) {\n          this.groupingArray_.push(groupingCount);\n        }\n        groupingCount = 0;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        if (decimalPos >= 0) {\n          throw new Error('Multiple decimal separators in pattern \"' + pattern + '\"');\n        }\n        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:\n        if (this.useExponentialNotation_) {\n          throw new Error('Multiple exponential symbols in pattern \"' + pattern + '\"');\n        }\n        this.useExponentialNotation_ = true;\n        this.minExponentDigits_ = 0;\n        if (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.PATTERN_PLUS_) {\n          pos[0]++;\n          this.useSignForPositiveExponent_ = true;\n        }\n        while (pos[0] + 1 < len && pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {\n          pos[0]++;\n          this.minExponentDigits_++;\n        }\n        if (digitLeftCount + zeroDigitCount < 1 || this.minExponentDigits_ < 1) {\n          throw new Error('Malformed exponential pattern \"' + pattern + '\"');\n        }\n        loop = false;\n        break;\n      default:\n        pos[0]--;\n        loop = false;\n        break;\n    }\n  }\n  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {\n    var n = decimalPos;\n    if (n == 0) {\n      n++;\n    }\n    digitRightCount = digitLeftCount - n;\n    digitLeftCount = n - 1;\n    zeroDigitCount = 1;\n  }\n  if (decimalPos < 0 && digitRightCount > 0 || decimalPos >= 0 && (decimalPos < digitLeftCount || decimalPos > digitLeftCount + zeroDigitCount) || groupingCount == 0) {\n    throw new Error('Malformed pattern \"' + pattern + '\"');\n  }\n  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;\n  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;\n  if (decimalPos >= 0) {\n    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;\n    if (this.minimumFractionDigits_ < 0) {\n      this.minimumFractionDigits_ = 0;\n    }\n  }\n  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;\n  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;\n  if (this.useExponentialNotation_) {\n    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;\n    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {\n      this.minimumIntegerDigits_ = 1;\n    }\n  }\n  this.groupingArray_.push(Math.max(0, groupingCount));\n  this.decimalSeparatorAlwaysShown_ = decimalPos == 0 || decimalPos == totalDigits;\n};\n/** @typedef {{prefix:string,suffix:string,divisorBase:number}} */ goog.i18n.NumberFormat.CompactNumberUnit;\n/** @private @type {!goog.i18n.NumberFormat.CompactNumberUnit} */ goog.i18n.NumberFormat.NULL_UNIT_ = {prefix:\"\", suffix:\"\", divisorBase:0};\n/**\n * @private\n * @param {number} base\n * @param {string} plurality\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit}\n */\ngoog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {\n  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ? goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN : goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;\n  if (!goog.isDefAndNotNull(table)) {\n    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;\n  }\n  if (base < 3) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  } else {\n    var shift = goog.i18n.NumberFormat.decimalShift_;\n    base = Math.min(14, base);\n    var patterns = table[shift(1, base)];\n    var previousNonNullBase = base - 1;\n    while (!patterns && previousNonNullBase >= 3) {\n      patterns = table[shift(1, previousNonNullBase)];\n      previousNonNullBase--;\n    }\n    if (!patterns) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n    var pattern = patterns[plurality];\n    if (!pattern || pattern == \"0\") {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n    var parts = /([^0]*)(0+)(.*)/.exec(pattern);\n    if (!parts) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n    return {prefix:parts[1], suffix:parts[3], divisorBase:previousNonNullBase + 1 - (parts[2].length - 1)};\n  }\n};\n/**\n * @private\n * @param {number} formattingNumber\n * @param {number} pluralityNumber\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit}\n */\ngoog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(formattingNumber, pluralityNumber) {\n  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  }\n  formattingNumber = Math.abs(formattingNumber);\n  pluralityNumber = Math.abs(pluralityNumber);\n  var initialPlurality = this.pluralForm_(formattingNumber);\n  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);\n  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;\n  var pluralityAttempt = goog.i18n.NumberFormat.decimalShift_(pluralityNumber, -initialDivisor);\n  var pluralityRounded = this.roundNumber_(pluralityAttempt);\n  var formattingAttempt = goog.i18n.NumberFormat.decimalShift_(formattingNumber, -initialDivisor);\n  var formattingRounded = this.roundNumber_(formattingAttempt);\n  var finalPlurality = this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);\n  return this.getUnitFor_(initialDivisor + this.intLog10_(formattingRounded.intValue), finalPlurality);\n};\n/**\n * @private\n * @param {number} number\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.intLog10_ = function(number) {\n  if (!isFinite(number)) {\n    return number > 0 ? number : 0;\n  }\n  var i = 0;\n  while ((number /= 10) >= 1) {\n    i++;\n  }\n  return i;\n};\n/**\n * @private\n * @param {number} number\n * @param {number} digitCount\n * @return {number}\n */\ngoog.i18n.NumberFormat.decimalShift_ = function(number, digitCount) {\n  goog.asserts.assert(digitCount % 1 == 0, 'Cannot shift by fractional digits \"%s\".', digitCount);\n  if (!number || !isFinite(number) || digitCount == 0) {\n    return number;\n  }\n  var numParts = String(number).split(\"e\");\n  var magnitude = parseInt(numParts[1] || 0, 10) + digitCount;\n  return parseFloat(numParts[0] + \"e\" + magnitude);\n};\n/**\n * @private\n * @param {number} number\n * @param {number} decimalCount\n * @return {number}\n */\ngoog.i18n.NumberFormat.decimalRound_ = function(number, decimalCount) {\n  goog.asserts.assert(decimalCount % 1 == 0, 'Cannot round to fractional digits \"%s\".', decimalCount);\n  if (!number || !isFinite(number)) {\n    return number;\n  }\n  var shift = goog.i18n.NumberFormat.decimalShift_;\n  return shift(Math.round(shift(number, decimalCount)), -decimalCount);\n};\n/**\n * @private\n * @param {number} number\n * @param {number} significantDigits\n * @param {number} scale\n * @return {number}\n */\ngoog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(number, significantDigits, scale) {\n  if (!number) {\n    return number;\n  }\n  var digits = this.intLog10_(number);\n  var magnitude = significantDigits - digits - 1;\n  if (magnitude < -scale) {\n    return goog.i18n.NumberFormat.decimalRound_(number, -scale);\n  } else {\n    return goog.i18n.NumberFormat.decimalRound_(number, magnitude);\n  }\n};\n/**\n * @private\n * @param {number} quantity\n * @return {string}\n */\ngoog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {\n  return \"other\";\n};\n/**\n * @return {boolean}\n */\ngoog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {\n  var posCurrSymbol = this.pattern_.indexOf(\"¤\");\n  var posPound = this.pattern_.indexOf(\"#\");\n  var posZero = this.pattern_.indexOf(\"0\");\n  var posCurrValue = Number.MAX_VALUE;\n  if (posPound >= 0 && posPound < posCurrValue) {\n    posCurrValue = posPound;\n  }\n  if (posZero >= 0 && posZero < posCurrValue) {\n    posCurrValue = posZero;\n  }\n  return posCurrSymbol < posCurrValue;\n};\n","~:source","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Number format/parse library with locale support.\n */\n\n\n/**\n * Namespace for locale number format functions\n */\ngoog.provide('goog.i18n.NumberFormat');\ngoog.provide('goog.i18n.NumberFormat.CurrencyStyle');\ngoog.provide('goog.i18n.NumberFormat.Format');\n\ngoog.require('goog.asserts');\ngoog.require('goog.i18n.CompactNumberFormatSymbols');\ngoog.require('goog.i18n.NumberFormatSymbols');\ngoog.require('goog.i18n.NumberFormatSymbols_u_nu_latn');\ngoog.require('goog.i18n.currency');\ngoog.require('goog.math');\ngoog.require('goog.string');\n\n\n\n/**\n * Constructor of NumberFormat.\n * @param {number|string} pattern The number that indicates a predefined\n *     number format pattern.\n * @param {string=} opt_currency Optional international currency\n *     code. This determines the currency code/symbol used in format/parse. If\n *     not given, the currency code for the current locale will be used.\n * @param {number=} opt_currencyStyle currency style, value defined in\n *     goog.i18n.NumberFormat.CurrencyStyle. If not given, the currency style\n *     for the current locale will be used.\n * @param {!Object<string, string>=} opt_symbols Optional number format symbols\n *     map, analogous to goog.i18n.NumberFormatSymbols. If present, this\n *     overrides the symbols from the current locale, such as the percent sign\n *     and minus sign.\n * @constructor\n */\ngoog.i18n.NumberFormat = function(\n    pattern, opt_currency, opt_currencyStyle, opt_symbols) {\n  /** @const @private {?string} */\n  this.intlCurrencyCode_ = opt_currency || null;\n\n  /** @const @private {number} */\n  this.currencyStyle_ =\n      opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;\n\n  /** @const @private {?Object<string, string>} */\n  this.overrideNumberFormatSymbols_ = opt_symbols || null;\n\n  /** @private {number} */\n  this.maximumIntegerDigits_ = 40;\n  /** @private {number} */\n  this.minimumIntegerDigits_ = 1;\n  /** @private {number} */\n  this.significantDigits_ = 0;  // invariant, <= maximumFractionDigits\n  /** @private {number} */\n  this.maximumFractionDigits_ = 3;  // invariant, >= minFractionDigits\n  /** @private {number} */\n  this.minimumFractionDigits_ = 0;\n  /** @private {number} */\n  this.minExponentDigits_ = 0;\n  /** @private {boolean} */\n  this.useSignForPositiveExponent_ = false;\n\n  /**\n   * Whether to show trailing zeros in the fraction when significantDigits_ is\n   * positive.\n   * @private {boolean}\n   */\n  this.showTrailingZeros_ = false;\n\n  /** @private {string} */\n  this.positivePrefix_ = '';\n  /** @private {string} */\n  this.positiveSuffix_ = '';\n  /** @private {string} */\n  this.negativePrefix_ = this.getNumberFormatSymbols_().MINUS_SIGN;\n  /** @private {string} */\n  this.negativeSuffix_ = '';\n\n  // The multiplier for use in percent, per mille, etc.\n  /** @private {number} */\n  this.multiplier_ = 1;\n\n  /**\n   * True if the percent/permill sign of the negative pattern is expected.\n   * @private {boolean}\n   */\n  this.negativePercentSignExpected_ = false;\n\n  /**\n   * The grouping array is used to store the values of each number group\n   * following left of the decimal place. For example, a number group with\n   * goog.i18n.NumberFormat('#,##,###') should have [3,2] where 2 is the\n   * repeated number group following a fixed number grouping of size 3.\n   * @private {!Array<number>}\n   */\n  this.groupingArray_ = [];\n\n  /** @private {boolean} */\n  this.decimalSeparatorAlwaysShown_ = false;\n  /** @private {boolean} */\n  this.useExponentialNotation_ = false;\n  /** @private {goog.i18n.NumberFormat.CompactStyle} */\n  this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;\n\n  /**\n   * The number to base the formatting on when using compact styles, or null\n   * if formatting should not be based on another number.\n   * @type {?number}\n   * @private\n   */\n  this.baseFormattingNumber_ = null;\n\n  /** @private {string} */\n  this.pattern_;\n\n  if (typeof pattern == 'number') {\n    this.applyStandardPattern_(pattern);\n  } else {\n    this.applyPattern_(pattern);\n  }\n};\n\n\n/**\n * Standard number formatting patterns.\n * @enum {number}\n */\ngoog.i18n.NumberFormat.Format = {\n  DECIMAL: 1,\n  SCIENTIFIC: 2,\n  PERCENT: 3,\n  CURRENCY: 4,\n  COMPACT_SHORT: 5,\n  COMPACT_LONG: 6\n};\n\n\n/**\n * Currency styles.\n * @enum {number}\n */\ngoog.i18n.NumberFormat.CurrencyStyle = {\n  LOCAL: 0,     // currency style as it is used in its circulating country.\n  PORTABLE: 1,  // currency style that differentiate it from other popular ones.\n  GLOBAL: 2     // currency style that is unique among all currencies.\n};\n\n\n/**\n * Compacting styles.\n * @enum {number}\n */\ngoog.i18n.NumberFormat.CompactStyle = {\n  NONE: 0,   // Don't compact.\n  SHORT: 1,  // Short compact form, such as 1.2B.\n  LONG: 2    // Long compact form, such as 1.2 billion.\n};\n\n\n/**\n * If the usage of Ascii digits should be enforced.\n * @type {boolean}\n * @private\n */\ngoog.i18n.NumberFormat.enforceAsciiDigits_ = false;\n\n\n/**\n * Set if the usage of Ascii digits in formatting should be enforced.\n * NOTE: This function must be called before constructing NumberFormat.\n *\n * @param {boolean} doEnforce Boolean value about if Ascii digits should be\n *     enforced.\n */\ngoog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {\n  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;\n};\n\n\n/**\n * Return if Ascii digits is enforced.\n * @return {boolean} If Ascii digits is enforced.\n */\ngoog.i18n.NumberFormat.isEnforceAsciiDigits = function() {\n  return goog.i18n.NumberFormat.enforceAsciiDigits_;\n};\n\n\n/**\n * Returns the current NumberFormatSymbols.\n * @return {!Object}\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getNumberFormatSymbols_ = function() {\n  return this.overrideNumberFormatSymbols_ ||\n      (goog.i18n.NumberFormat.enforceAsciiDigits_ ?\n           goog.i18n.NumberFormatSymbols_u_nu_latn :\n           goog.i18n.NumberFormatSymbols);\n};\n\n\n/**\n * Returns the currency code.\n * @return {string}\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {\n  return this.intlCurrencyCode_ ||\n      this.getNumberFormatSymbols_().DEF_CURRENCY_CODE;\n};\n\n\n/**\n * Sets minimum number of fraction digits.\n * @param {number} min the minimum.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {\n  if (this.significantDigits_ > 0 && min > 0) {\n    throw new Error(\n        'Can\\'t combine significant digits and minimum fraction digits');\n  }\n  this.minimumFractionDigits_ = min;\n  return this;\n};\n\n\n/**\n * Gets minimum number of fraction digits.\n * @return {number} The number of minimum fraction digits.\n */\ngoog.i18n.NumberFormat.prototype.getMinimumFractionDigits = function() {\n  return this.minimumFractionDigits_;\n};\n\n\n/**\n * Sets maximum number of fraction digits.\n * @param {number} max the maximum.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {\n  if (max > 308) {\n    // Math.pow(10, 309) becomes Infinity which breaks the logic in this class.\n    throw new Error('Unsupported maximum fraction digits: ' + max);\n  }\n  this.maximumFractionDigits_ = max;\n  return this;\n};\n\n\n/**\n * Gets maximum number of fraction digits.\n * @return {number} The number of maximum fraction digits.\n */\ngoog.i18n.NumberFormat.prototype.getMaximumFractionDigits = function() {\n  return this.maximumFractionDigits_;\n};\n\n/**\n * Sets number of significant digits to show. Only fractions will be rounded.\n * Regardless of the number of significant digits set, the number of fractional\n * digits shown will always be capped by the maximum number of fractional digits\n * set on {@link #setMaximumFractionDigits}.\n * @param {number} number The number of significant digits to include.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {\n  if (this.minimumFractionDigits_ > 0 && number >= 0) {\n    throw new Error(\n        'Can\\'t combine significant digits and minimum fraction digits');\n  }\n  this.significantDigits_ = number;\n  return this;\n};\n\n\n/**\n * Gets number of significant digits to show. Only fractions will be rounded.\n * @return {number} The number of significant digits to include.\n */\ngoog.i18n.NumberFormat.prototype.getSignificantDigits = function() {\n  return this.significantDigits_;\n};\n\n\n/**\n * Sets whether trailing fraction zeros should be shown when significantDigits_\n * is positive. If this is true and significantDigits_ is 2, 1 will be formatted\n * as '1.0'.\n * @param {boolean} showTrailingZeros Whether trailing zeros should be shown.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(\n    showTrailingZeros) {\n  this.showTrailingZeros_ = showTrailingZeros;\n  return this;\n};\n\n\n/**\n * Sets a number to base the formatting on when compact style formatting is\n * used. If this is null, the formatting should be based only on the number to\n * be formatting.\n *\n * This base formatting number can be used to format the target number as\n * another number would be formatted. For example, 100,000 is normally formatted\n * as \"100K\" in the COMPACT_SHORT format. To instead format it as '0.1M', the\n * base number could be set to 1,000,000 in order to force all numbers to be\n * formatted in millions. Similarly, 1,000,000,000 would normally be formatted\n * as '1B' and setting the base formatting number to 1,000,000, would cause it\n * to be formatted instead as '1,000M'.\n *\n * @param {?number} baseFormattingNumber The number to base formatting on, or\n * null if formatting should not be based on another number.\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\n */\ngoog.i18n.NumberFormat.prototype.setBaseFormatting = function(\n    baseFormattingNumber) {\n  goog.asserts.assert(\n      goog.isNull(baseFormattingNumber) || isFinite(baseFormattingNumber));\n  this.baseFormattingNumber_ = baseFormattingNumber;\n  return this;\n};\n\n\n/**\n * Gets the number on which compact formatting is currently based, or null if\n * no such number is set. See setBaseFormatting() for more information.\n * @return {?number}\n */\ngoog.i18n.NumberFormat.prototype.getBaseFormatting = function() {\n  return this.baseFormattingNumber_;\n};\n\n\n/**\n * Apply provided pattern, result are stored in member variables.\n *\n * @param {string} pattern String pattern being applied.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {\n  this.pattern_ = pattern.replace(/ /g, '\\u00a0');\n  var pos = [0];\n\n  this.positivePrefix_ = this.parseAffix_(pattern, pos);\n  var trunkStart = pos[0];\n  this.parseTrunk_(pattern, pos);\n  var trunkLen = pos[0] - trunkStart;\n  this.positiveSuffix_ = this.parseAffix_(pattern, pos);\n  if (pos[0] < pattern.length &&\n      pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {\n    pos[0]++;\n    if (this.multiplier_ != 1) this.negativePercentSignExpected_ = true;\n    this.negativePrefix_ = this.parseAffix_(pattern, pos);\n    // we assume this part is identical to positive part.\n    // user must make sure the pattern is correctly constructed.\n    pos[0] += trunkLen;\n    this.negativeSuffix_ = this.parseAffix_(pattern, pos);\n  } else {\n    // if no negative affix specified, they share the same positive affix\n    this.negativePrefix_ += this.positivePrefix_;\n    this.negativeSuffix_ += this.positiveSuffix_;\n  }\n};\n\n\n/**\n * Apply a predefined pattern to NumberFormat object.\n * @param {number} patternType The number that indicates a predefined number\n *     format pattern.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {\n  switch (patternType) {\n    case goog.i18n.NumberFormat.Format.DECIMAL:\n      this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.SCIENTIFIC:\n      this.applyPattern_(this.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.PERCENT:\n      this.applyPattern_(this.getNumberFormatSymbols_().PERCENT_PATTERN);\n      break;\n    case goog.i18n.NumberFormat.Format.CURRENCY:\n      this.applyPattern_(goog.i18n.currency.adjustPrecision(\n          this.getNumberFormatSymbols_().CURRENCY_PATTERN,\n          this.getCurrencyCode_()));\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);\n      break;\n    case goog.i18n.NumberFormat.Format.COMPACT_LONG:\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);\n      break;\n    default:\n      throw new Error('Unsupported pattern type.');\n  }\n};\n\n\n/**\n * Apply a predefined pattern for shorthand formats.\n * @param {goog.i18n.NumberFormat.CompactStyle} style the compact style to\n *     set defaults for.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {\n  this.compactStyle_ = style;\n  this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);\n  this.setMinimumFractionDigits(0);\n  this.setMaximumFractionDigits(2);\n  this.setSignificantDigits(2);\n};\n\n\n/**\n * Parses text string to produce a Number.\n *\n * This method attempts to parse text starting from position \"opt_pos\" if it\n * is given. Otherwise the parse will start from the beginning of the text.\n * When opt_pos presents, opt_pos will be updated to the character next to where\n * parsing stops after the call. If an error occurs, opt_pos won't be updated.\n *\n * @param {string} text The string to be parsed.\n * @param {Array<number>=} opt_pos Position to pass in and get back.\n * @return {number} Parsed number. This throws an error if the text cannot be\n *     parsed.\n */\ngoog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {\n  var pos = opt_pos || [0];\n\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw new Error('Parsing of compact numbers is unimplemented');\n  }\n\n  var ret = NaN;\n\n  // We don't want to handle multiple kinds of space in parsing, normalize the\n  // regular and narrow nbsp to nbsp.\n  text = text.replace(/ |\\u202f/g, '\\u00a0');\n\n  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];\n  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];\n\n  // check for the longest match\n  if (gotPositive && gotNegative) {\n    if (this.positivePrefix_.length > this.negativePrefix_.length) {\n      gotNegative = false;\n    } else if (this.positivePrefix_.length < this.negativePrefix_.length) {\n      gotPositive = false;\n    }\n  }\n\n  if (gotPositive) {\n    pos[0] += this.positivePrefix_.length;\n  } else if (gotNegative) {\n    pos[0] += this.negativePrefix_.length;\n  }\n\n  // process digits or Inf, find decimal position\n  if (text.indexOf(this.getNumberFormatSymbols_().INFINITY, pos[0]) == pos[0]) {\n    pos[0] += this.getNumberFormatSymbols_().INFINITY.length;\n    ret = Infinity;\n  } else {\n    ret = this.parseNumber_(text, pos);\n  }\n\n  // check for suffix\n  if (gotPositive) {\n    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {\n      return NaN;\n    }\n    pos[0] += this.positiveSuffix_.length;\n  } else if (gotNegative) {\n    if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {\n      return NaN;\n    }\n    pos[0] += this.negativeSuffix_.length;\n  }\n\n  return gotNegative ? -ret : ret;\n};\n\n\n/**\n * This function will parse a \"localized\" text into a Number. It needs to\n * handle locale specific decimal, grouping, exponent and digits.\n *\n * @param {string} text The text that need to be parsed.\n * @param {Array<number>} pos  In/out parsing position. In case of failure,\n *    pos value won't be changed.\n * @return {number} Number value, or NaN if nothing can be parsed.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {\n  var sawDecimal = false;\n  var sawExponent = false;\n  var sawDigit = false;\n  var exponentPos = -1;\n  var scale = 1;\n  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\n  var exponentChar = this.getNumberFormatSymbols_().EXP_SYMBOL;\n\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\n    throw new Error('Parsing of compact style numbers is not implemented');\n  }\n\n  // We don't want to handle multiple kinds of space in parsing, normalize the\n  // narrow nbsp to nbsp.\n  grouping = grouping.replace(/\\u202f/g, '\\u00a0');\n\n  var normalizedText = '';\n  for (; pos[0] < text.length; pos[0]++) {\n    var ch = text.charAt(pos[0]);\n    var digit = this.getDigit_(ch);\n    if (digit >= 0 && digit <= 9) {\n      normalizedText += digit;\n      sawDigit = true;\n    } else if (ch == decimal.charAt(0)) {\n      if (sawDecimal || sawExponent) {\n        break;\n      }\n      normalizedText += '.';\n      sawDecimal = true;\n    } else if (\n        ch == grouping.charAt(0) &&\n        ('\\u00a0' != grouping.charAt(0) ||\n         pos[0] + 1 < text.length &&\n             this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {\n      // Got a grouping character here. When grouping character is nbsp, need\n      // to make sure the character following it is a digit.\n      if (sawDecimal || sawExponent) {\n        break;\n      }\n      continue;\n    } else if (ch == exponentChar.charAt(0)) {\n      if (sawExponent) {\n        break;\n      }\n      normalizedText += 'E';\n      sawExponent = true;\n      exponentPos = pos[0];\n    } else if (ch == '+' || ch == '-') {\n      // Stop parsing if a '+' or '-' sign is found after digits have been found\n      // but it's not located right after an exponent sign.\n      if (sawDigit && exponentPos != pos[0] - 1) {\n        break;\n      }\n      normalizedText += ch;\n    } else if (\n        this.multiplier_ == 1 &&\n        ch == this.getNumberFormatSymbols_().PERCENT.charAt(0)) {\n      // Parse the percent character as part of the number only when it's\n      // not already included in the pattern.\n      if (scale != 1) {\n        break;\n      }\n      scale = 100;\n      if (sawDigit) {\n        pos[0]++;  // eat this character if parse end here\n        break;\n      }\n    } else if (\n        this.multiplier_ == 1 &&\n        ch == this.getNumberFormatSymbols_().PERMILL.charAt(0)) {\n      // Parse the permill character as part of the number only when it's\n      // not already included in the pattern.\n      if (scale != 1) {\n        break;\n      }\n      scale = 1000;\n      if (sawDigit) {\n        pos[0]++;  // eat this character if parse end here\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n\n  // Scale the number when the percent/permill character was included in\n  // the pattern.\n  if (this.multiplier_ != 1) {\n    scale = this.multiplier_;\n  }\n\n  return parseFloat(normalizedText) / scale;\n};\n\n\n/**\n * Formats a Number to produce a string.\n *\n * @param {number} number The Number to be formatted.\n * @return {string} The formatted number string.\n */\ngoog.i18n.NumberFormat.prototype.format = function(number) {\n  if (isNaN(number)) {\n    return this.getNumberFormatSymbols_().NAN;\n  }\n\n  var parts = [];\n  var baseFormattingNumber = goog.isNull(this.baseFormattingNumber_) ?\n      number :\n      this.baseFormattingNumber_;\n  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);\n  number = goog.i18n.NumberFormat.decimalShift_(number, -unit.divisorBase);\n\n  parts.push(unit.prefix);\n\n  // in icu code, it is commented that certain computation need to keep the\n  // negative sign for 0.\n  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;\n\n  parts.push(isNegative ? this.negativePrefix_ : this.positivePrefix_);\n\n  if (!isFinite(number)) {\n    parts.push(this.getNumberFormatSymbols_().INFINITY);\n  } else {\n    // convert number to non-negative value\n    number *= isNegative ? -1 : 1;\n\n    number *= this.multiplier_;\n    this.useExponentialNotation_ ?\n        this.subformatExponential_(number, parts) :\n        this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n  }\n\n  parts.push(isNegative ? this.negativeSuffix_ : this.positiveSuffix_);\n  parts.push(unit.suffix);\n\n  return parts.join('');\n};\n\n\n/**\n * Round a number into an integer and fractional part\n * based on the rounding rules for this NumberFormat.\n * @param {number} number The number to round.\n * @return {{intValue: number, fracValue: number}} The integer and fractional\n *     part after rounding.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {\n  var shift = goog.i18n.NumberFormat.decimalShift_;\n\n  var shiftedNumber = shift(number, this.maximumFractionDigits_);\n  if (this.significantDigits_ > 0) {\n    shiftedNumber = this.roundToSignificantDigits_(\n        shiftedNumber, this.significantDigits_, this.maximumFractionDigits_);\n  }\n  shiftedNumber = Math.round(shiftedNumber);\n\n  var intValue, fracValue;\n  if (isFinite(shiftedNumber)) {\n    intValue = Math.floor(shift(shiftedNumber, -this.maximumFractionDigits_));\n    fracValue = Math.floor(\n        shiftedNumber - shift(intValue, this.maximumFractionDigits_));\n  } else {\n    intValue = number;\n    fracValue = 0;\n  }\n  return {intValue: intValue, fracValue: fracValue};\n};\n\n\n/**\n * Formats a number with the appropriate groupings when there are repeating\n * digits present. Repeating digits exists when the length of the digits left\n * of the decimal place exceeds the number of non-repeating digits.\n *\n * Formats a number by iterating through the integer number (intPart) from the\n * most left of the decimal place by inserting the appropriate number grouping\n * separator for the repeating digits until all of the repeating digits is\n * iterated. Then iterate through the non-repeating digits by inserting the\n * appropriate number grouping separator until all the non-repeating digits\n * is iterated through.\n *\n * In the number grouping concept, anything left of the decimal\n * place is followed by non-repeating digits and then repeating digits. If the\n * pattern is #,##,###, then we first (from the left of the decimal place) have\n * a non-repeating digit of size 3 followed by repeating digits of size 2\n * separated by a thousand separator. If the length of the digits are six or\n * more, there may be repeating digits required. For example, the value of\n * 12345678 would format as 1,23,45,678 where the repeating digit is length 2.\n *\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\n *  number including the values and separators.\n * @param {number} zeroCode The value of the zero digit whether or not\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\n * @param {string} intPart The integer representation of the number to be\n *  formatted and referenced.\n * @param {!Array<number>} groupingArray The array of numbers to determine the\n *  grouping of repeated and non-repeated digits.\n * @param {number} repeatedDigitLen The length of the repeated digits left of\n *  the non-repeating digits left of the decimal.\n * @return {!Array<string>} Returns the resulting parts variable containing\n *  how numbers are to be grouped and appear.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.formatNumberGroupingRepeatingDigitsParts_ =\n    function(parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {\n  // Keep track of how much has been completed on the non repeated groups\n  var nonRepeatedGroupCompleteCount = 0;\n  var currentGroupSizeIndex = 0;\n  var currentGroupSize = 0;\n\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\n  var digitLen = intPart.length;\n\n  // There are repeating digits and non-repeating digits\n  for (var i = 0; i < digitLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));\n    if (digitLen - i > 1) {\n      currentGroupSize = groupingArray[currentGroupSizeIndex];\n      if (i < repeatedDigitLen) {\n        // Process the left side (the repeated number groups)\n        var repeatedDigitIndex = repeatedDigitLen - i;\n        // Edge case if there's a number grouping asking for \"1\" group at\n        // a time; otherwise, if the remainder is 1, there's the separator\n        if (currentGroupSize === 1 ||\n            (currentGroupSize > 0 &&\n             (repeatedDigitIndex % currentGroupSize) === 1)) {\n          parts.push(grouping);\n        }\n      } else if (currentGroupSizeIndex < groupingArray.length) {\n        // Process the right side (the non-repeated fixed number groups)\n        if (i === repeatedDigitLen) {\n          // Increase the group index because a separator\n          // has previously added in the earlier logic\n          currentGroupSizeIndex += 1;\n        } else if (\n            currentGroupSize ===\n            i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {\n          // Otherwise, just iterate to the right side and\n          // add a separator once the length matches to the expected\n          parts.push(grouping);\n          // Keep track of what has been completed on the right\n          nonRepeatedGroupCompleteCount += currentGroupSize;\n          currentGroupSizeIndex += 1;  // Get to the next number grouping\n        }\n      }\n    }\n  }\n  return parts;\n};\n\n\n/**\n * Formats a number with the appropriate groupings when there are no repeating\n * digits present. Non-repeating digits exists when the length of the digits\n * left of the decimal place is equal or lesser than the length of\n * non-repeating digits.\n *\n * Formats a number by iterating through the integer number (intPart) from the\n * right most non-repeating number group of the decimal place. For each group,\n * inserting the appropriate number grouping separator for the non-repeating\n * digits until the number is completely iterated.\n *\n * In the number grouping concept, anything left of the decimal\n * place is followed by non-repeating digits and then repeating digits. If the\n * pattern is #,##,###, then we first (from the left of the decimal place) have\n * a non-repeating digit of size 3 followed by repeating digits of size 2\n * separated by a thousand separator. If the length of the digits are five or\n * less, there won't be any repeating digits required. For example, the value\n * of 12345 would be formatted as 12,345 where the non-repeating digit is of\n * length 3.\n *\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\n *  number including the values and separators.\n * @param {number} zeroCode The value of the zero digit whether or not\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\n * @param {string} intPart The integer representation of the number to be\n *  formatted and referenced.\n * @param {!Array<number>} groupingArray The array of numbers to determine the\n *  grouping of repeated and non-repeated digits.\n * @return {!Array<string>} Returns the resulting parts variable containing\n *  how numbers are to be grouped and appear.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.formatNumberGroupingNonRepeatingDigitsParts_ =\n    function(parts, zeroCode, intPart, groupingArray) {\n  // Keep track of how much has been completed on the non repeated groups\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\n  var currentGroupSizeIndex;\n  var currentGroupSize = 0;\n  var digitLenLeft = intPart.length;\n  var rightToLeftParts = [];\n\n  // Start from the right most non-repeating group and work inwards\n  for (currentGroupSizeIndex = groupingArray.length - 1;\n       currentGroupSizeIndex >= 0 && digitLenLeft > 0;\n       currentGroupSizeIndex--) {\n    currentGroupSize = groupingArray[currentGroupSizeIndex];\n    // Iterate from the right most digit\n    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize &&\n         ((digitLenLeft - rightDigitIndex - 1) >= 0);\n         rightDigitIndex++) {\n      rightToLeftParts.push(String.fromCharCode(\n          zeroCode +\n          Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));\n    }\n    // Update the number of digits left\n    digitLenLeft -= currentGroupSize;\n    if (digitLenLeft > 0) {\n      rightToLeftParts.push(grouping);\n    }\n  }\n  // Reverse and push onto the remaining parts\n  parts.push.apply(parts, rightToLeftParts.reverse());\n\n  return parts;\n};\n\n\n/**\n * Formats a Number in fraction format.\n *\n * @param {number} number\n * @param {number} minIntDigits Minimum integer digits.\n * @param {Array<string>} parts\n *     This array holds the pieces of formatted string.\n *     This function will add its formatted pieces to the array.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.subformatFixed_ = function(\n    number, minIntDigits, parts) {\n  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {\n    throw new Error('Min value must be less than max value');\n  }\n\n  if (!parts) {\n    parts = [];\n  }\n\n  var rounded = this.roundNumber_(number);\n  var intValue = rounded.intValue;\n  var fracValue = rounded.fracValue;\n\n  var numIntDigits = (intValue == 0) ? 0 : this.intLog10_(intValue) + 1;\n  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 ||\n      (this.showTrailingZeros_ && numIntDigits < this.significantDigits_);\n  var minimumFractionDigits = this.minimumFractionDigits_;\n  if (fractionPresent) {\n    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {\n      minimumFractionDigits = this.significantDigits_ - numIntDigits;\n    } else {\n      minimumFractionDigits = this.minimumFractionDigits_;\n    }\n  }\n\n  var intPart = '';\n  var translatableInt = intValue;\n  while (translatableInt > 1E20) {\n    // here it goes beyond double precision, add '0' make it look better\n    intPart = '0' + intPart;\n    translatableInt =\n        Math.round(goog.i18n.NumberFormat.decimalShift_(translatableInt, -1));\n  }\n  intPart = translatableInt + intPart;\n\n  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;\n  var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n  var digitLen = intPart.length;\n  var nonRepeatedGroupCount = 0;\n\n  if (intValue > 0 || minIntDigits > 0) {\n    for (var i = digitLen; i < minIntDigits; i++) {\n      parts.push(String.fromCharCode(zeroCode));\n    }\n\n    // If there's more than 1 number grouping,\n    // figure out the length of the non-repeated groupings (on the right)\n    if (this.groupingArray_.length >= 2) {\n      for (var j = 1; j < this.groupingArray_.length; j++) {\n        nonRepeatedGroupCount += this.groupingArray_[j];\n      }\n    }\n\n    // Anything left of the fixed number grouping is repeated,\n    // figure out the length of repeated groupings (on the left)\n    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;\n    if (repeatedDigitLen > 0) {\n      // There are repeating digits and non-repeating digits\n      parts = this.formatNumberGroupingRepeatingDigitsParts_(\n          parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);\n    } else {\n      // There are no repeating digits and only non-repeating digits\n      parts = this.formatNumberGroupingNonRepeatingDigitsParts_(\n          parts, zeroCode, intPart, this.groupingArray_);\n    }\n  } else if (!fractionPresent) {\n    // If there is no fraction present, and we haven't printed any\n    // integer digits, then print a zero.\n    parts.push(String.fromCharCode(zeroCode));\n  }\n\n  // Output the decimal separator if we always do so.\n  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {\n    parts.push(decimal);\n  }\n\n  var fracPart = String(fracValue);\n  // Handle case where fracPart is in scientific notation.\n  var fracPartSplit = fracPart.split('e+');\n  if (fracPartSplit.length == 2) {\n    // Only keep significant digits.\n    var floatFrac = parseFloat(fracPartSplit[0]);\n    fracPart = String(\n        this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));\n    fracPart = fracPart.replace('.', '');\n    // Append zeroes based on the exponent.\n    var exp = parseInt(fracPartSplit[1], 10);\n    fracPart += goog.string.repeat('0', exp - fracPart.length + 1);\n  }\n\n  // Add Math.pow(10, this.maximumFractionDigits) to fracPart. Uses string ops\n  // to avoid complexity with scientific notation and overflows.\n  if (this.maximumFractionDigits_ + 1 > fracPart.length) {\n    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;\n    fracPart = '1' + goog.string.repeat('0', zeroesToAdd) + fracPart;\n  }\n\n  var fracLen = fracPart.length;\n  while (fracPart.charAt(fracLen - 1) == '0' &&\n         fracLen > minimumFractionDigits + 1) {\n    fracLen--;\n  }\n\n  for (var i = 1; i < fracLen; i++) {\n    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));\n  }\n};\n\n\n/**\n * Formats exponent part of a Number.\n *\n * @param {number} exponent Exponential value.\n * @param {Array<string>} parts The array that holds the pieces of formatted\n *     string. This function will append more formatted pieces to the array.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {\n  parts.push(this.getNumberFormatSymbols_().EXP_SYMBOL);\n\n  if (exponent < 0) {\n    exponent = -exponent;\n    parts.push(this.getNumberFormatSymbols_().MINUS_SIGN);\n  } else if (this.useSignForPositiveExponent_) {\n    parts.push(this.getNumberFormatSymbols_().PLUS_SIGN);\n  }\n\n  var exponentDigits = '' + exponent;\n  var zeroChar = this.getNumberFormatSymbols_().ZERO_DIGIT;\n  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {\n    parts.push(zeroChar);\n  }\n  parts.push(exponentDigits);\n};\n\n/**\n * Returns the mantissa for the given value and its exponent.\n *\n * @param {number} value\n * @param {number} exponent\n * @return {number}\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {\n  return goog.i18n.NumberFormat.decimalShift_(value, -exponent);\n};\n\n/**\n * Formats Number in exponential format.\n *\n * @param {number} number Value need to be formatted.\n * @param {Array<string>} parts The array that holds the pieces of formatted\n *     string. This function will append more formatted pieces to the array.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.subformatExponential_ = function(\n    number, parts) {\n  if (number == 0.0) {\n    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\n    this.addExponentPart_(0, parts);\n    return;\n  }\n\n  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));\n  number = this.getMantissa_(number, exponent);\n\n  var minIntDigits = this.minimumIntegerDigits_;\n  if (this.maximumIntegerDigits_ > 1 &&\n      this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {\n    // A repeating range is defined; adjust to it as follows.\n    // If repeat == 3, we have 6,5,4=>3; 3,2,1=>0; 0,-1,-2=>-3;\n    // -3,-4,-5=>-6, etc. This takes into account that the\n    // exponent we have here is off by one from what we expect;\n    // it is for the format 0.MMMMMx10^n.\n    var remainder = exponent % this.maximumIntegerDigits_;\n    if (remainder < 0) {\n      remainder = this.maximumIntegerDigits_ + remainder;\n    }\n\n    number = goog.i18n.NumberFormat.decimalShift_(number, remainder);\n    exponent -= remainder;\n\n    minIntDigits = 1;\n  } else {\n    // No repeating range is defined; use minimum integer digits.\n    if (this.minimumIntegerDigits_ < 1) {\n      exponent++;\n      number = goog.i18n.NumberFormat.decimalShift_(number, -1);\n    } else {\n      exponent -= this.minimumIntegerDigits_ - 1;\n      number = goog.i18n.NumberFormat.decimalShift_(\n          number, this.minimumIntegerDigits_ - 1);\n    }\n  }\n  this.subformatFixed_(number, minIntDigits, parts);\n  this.addExponentPart_(exponent, parts);\n};\n\n\n/**\n * Returns the digit value of current character. The character could be either\n * '0' to '9', or a locale specific digit.\n *\n * @param {string} ch Character that represents a digit.\n * @return {number} The digit value, or -1 on error.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {\n  var code = ch.charCodeAt(0);\n  // between '0' to '9'\n  if (48 <= code && code < 58) {\n    return code - 48;\n  } else {\n    var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\n    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;\n  }\n};\n\n\n// ----------------------------------------------------------------------\n// CONSTANTS\n// ----------------------------------------------------------------------\n// Constants for characters used in programmatic (unlocalized) patterns.\n/**\n * A zero digit character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = '0';\n\n\n/**\n * A grouping separator character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = ',';\n\n\n/**\n * A decimal separator character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = '.';\n\n\n/**\n * A per mille character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_PER_MILLE_ = '\\u2030';\n\n\n/**\n * A percent character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_PERCENT_ = '%';\n\n\n/**\n * A digit character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_DIGIT_ = '#';\n\n\n/**\n * A separator character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_SEPARATOR_ = ';';\n\n\n/**\n * An exponent character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_EXPONENT_ = 'E';\n\n\n/**\n * A plus character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_PLUS_ = '+';\n\n\n/**\n * A generic currency sign character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = '\\u00A4';\n\n\n/**\n * A quote character.\n * @type {string}\n * @private\n */\ngoog.i18n.NumberFormat.QUOTE_ = '\\'';\n\n\n/**\n * Parses affix part of pattern.\n *\n * @param {string} pattern Pattern string that need to be parsed.\n * @param {Array<number>} pos One element position array to set and receive\n *     parsing position.\n *\n * @return {string} Affix received from parsing.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {\n  var affix = '';\n  var inQuote = false;\n  var len = pattern.length;\n\n  for (; pos[0] < len; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    if (ch == goog.i18n.NumberFormat.QUOTE_) {\n      if (pos[0] + 1 < len &&\n          pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {\n        pos[0]++;\n        affix += '\\'';  // 'don''t'\n      } else {\n        inQuote = !inQuote;\n      }\n      continue;\n    }\n\n    if (inQuote) {\n      affix += ch;\n    } else {\n      switch (ch) {\n        case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:\n          return affix;\n        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:\n          if ((pos[0] + 1) < len &&\n              pattern.charAt(pos[0] + 1) ==\n                  goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {\n            pos[0]++;\n            affix += this.getCurrencyCode_();\n          } else {\n            switch (this.currencyStyle_) {\n              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:\n                affix += goog.i18n.currency.getLocalCurrencySign(\n                    this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:\n                affix += goog.i18n.currency.getGlobalCurrencySign(\n                    this.getCurrencyCode_());\n                break;\n              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:\n                affix += goog.i18n.currency.getPortableCurrencySign(\n                    this.getCurrencyCode_());\n                break;\n              default:\n                break;\n            }\n          }\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PERCENT_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw new Error('Too many percent/permill');\n          } else if (\n              this.negativePercentSignExpected_ && this.multiplier_ != 100) {\n            throw new Error('Inconsistent use of percent/permill characters');\n          }\n          this.multiplier_ = 100;\n          this.negativePercentSignExpected_ = false;\n          affix += this.getNumberFormatSymbols_().PERCENT;\n          break;\n        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\n            throw new Error('Too many percent/permill');\n          } else if (\n              this.negativePercentSignExpected_ && this.multiplier_ != 1000) {\n            throw new Error('Inconsistent use of percent/permill characters');\n          }\n          this.multiplier_ = 1000;\n          this.negativePercentSignExpected_ = false;\n          affix += this.getNumberFormatSymbols_().PERMILL;\n          break;\n        default:\n          affix += ch;\n      }\n    }\n  }\n\n  return affix;\n};\n\n\n/**\n * Parses the trunk part of a pattern.\n *\n * @param {string} pattern Pattern string that need to be parsed.\n * @param {Array<number>} pos One element position array to set and receive\n *     parsing position.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {\n  var decimalPos = -1;\n  var digitLeftCount = 0;\n  var zeroDigitCount = 0;\n  var digitRightCount = 0;\n  var groupingCount = -1;\n  var len = pattern.length;\n  for (var loop = true; pos[0] < len && loop; pos[0]++) {\n    var ch = pattern.charAt(pos[0]);\n    switch (ch) {\n      case goog.i18n.NumberFormat.PATTERN_DIGIT_:\n        if (zeroDigitCount > 0) {\n          digitRightCount++;\n        } else {\n          digitLeftCount++;\n        }\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\n        if (digitRightCount > 0) {\n          throw new Error('Unexpected \"0\" in pattern \"' + pattern + '\"');\n        }\n        zeroDigitCount++;\n        if (groupingCount >= 0 && decimalPos < 0) {\n          groupingCount++;\n        }\n        break;\n      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\n        if (groupingCount > 0) {\n          this.groupingArray_.push(groupingCount);\n        }\n        groupingCount = 0;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\n        if (decimalPos >= 0) {\n          throw new Error(\n              'Multiple decimal separators in pattern \"' + pattern + '\"');\n        }\n        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;\n        break;\n      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:\n        if (this.useExponentialNotation_) {\n          throw new Error(\n              'Multiple exponential symbols in pattern \"' + pattern + '\"');\n        }\n        this.useExponentialNotation_ = true;\n        this.minExponentDigits_ = 0;\n\n        // exponent pattern can have a optional '+'.\n        if ((pos[0] + 1) < len &&\n            pattern.charAt(pos[0] + 1) ==\n                goog.i18n.NumberFormat.PATTERN_PLUS_) {\n          pos[0]++;\n          this.useSignForPositiveExponent_ = true;\n        }\n\n        // Use lookahead to parse out the exponential part\n        // of the pattern, then jump into phase 2.\n        while ((pos[0] + 1) < len &&\n               pattern.charAt(pos[0] + 1) ==\n                   goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {\n          pos[0]++;\n          this.minExponentDigits_++;\n        }\n\n        if ((digitLeftCount + zeroDigitCount) < 1 ||\n            this.minExponentDigits_ < 1) {\n          throw new Error('Malformed exponential pattern \"' + pattern + '\"');\n        }\n        loop = false;\n        break;\n      default:\n        pos[0]--;\n        loop = false;\n        break;\n    }\n  }\n\n  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {\n    // Handle '###.###' and '###.' and '.###'\n    var n = decimalPos;\n    if (n == 0) {  // Handle '.###'\n      n++;\n    }\n    digitRightCount = digitLeftCount - n;\n    digitLeftCount = n - 1;\n    zeroDigitCount = 1;\n  }\n\n  // Do syntax checking on the digits.\n  if (decimalPos < 0 && digitRightCount > 0 ||\n      decimalPos >= 0 && (decimalPos < digitLeftCount ||\n                          decimalPos > digitLeftCount + zeroDigitCount) ||\n      groupingCount == 0) {\n    throw new Error('Malformed pattern \"' + pattern + '\"');\n  }\n  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;\n\n  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;\n  if (decimalPos >= 0) {\n    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;\n    if (this.minimumFractionDigits_ < 0) {\n      this.minimumFractionDigits_ = 0;\n    }\n  }\n\n  // The effectiveDecimalPos is the position the decimal is at or would be at\n  // if there is no decimal. Note that if decimalPos<0, then digitTotalCount ==\n  // digitLeftCount + zeroDigitCount.\n  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;\n  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;\n  if (this.useExponentialNotation_) {\n    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;\n\n    // in exponential display, we need to at least show something.\n    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {\n      this.minimumIntegerDigits_ = 1;\n    }\n  }\n\n  // Add another number grouping at the end\n  this.groupingArray_.push(Math.max(0, groupingCount));\n  this.decimalSeparatorAlwaysShown_ =\n      decimalPos == 0 || decimalPos == totalDigits;\n};\n\n\n/**\n * Alias for the compact format 'unit' object.\n * @typedef {{\n *     prefix: string,\n *     suffix: string,\n *     divisorBase: number\n * }}\n */\ngoog.i18n.NumberFormat.CompactNumberUnit;\n\n\n/**\n * The empty unit, corresponding to a base of 0.\n * @private {!goog.i18n.NumberFormat.CompactNumberUnit}\n */\ngoog.i18n.NumberFormat.NULL_UNIT_ = {\n  prefix: '',\n  suffix: '',\n  divisorBase: 0\n};\n\n\n/**\n * Get compact unit for a certain number of digits\n *\n * @param {number} base The number of digits to get the unit for.\n * @param {string} plurality The plurality of the number.\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The compact unit.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {\n  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ?\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN :\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;\n\n  if (!goog.isDefAndNotNull(table)) {\n    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;\n  }\n\n  if (base < 3) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  } else {\n    var shift = goog.i18n.NumberFormat.decimalShift_;\n\n    base = Math.min(14, base);\n    var patterns = table[shift(1, base)];\n    var previousNonNullBase = base - 1;\n    while (!patterns && previousNonNullBase >= 3) {\n      patterns = table[shift(1, previousNonNullBase)];\n      previousNonNullBase--;\n    }\n    if (!patterns) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n\n    var pattern = patterns[plurality];\n    if (!pattern || pattern == '0') {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n\n    var parts = /([^0]*)(0+)(.*)/.exec(pattern);\n    if (!parts) {\n      return goog.i18n.NumberFormat.NULL_UNIT_;\n    }\n\n    return {\n      prefix: parts[1],\n      suffix: parts[3],\n      divisorBase: (previousNonNullBase + 1) - (parts[2].length - 1)\n    };\n  }\n};\n\n\n/**\n * Get the compact unit divisor, accounting for rounding of the quantity.\n *\n * @param {number} formattingNumber The number to base the formatting on. The\n *     unit will be calculated from this number.\n * @param {number} pluralityNumber The number to use for calculating the\n *     plurality.\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The unit after rounding.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(\n    formattingNumber, pluralityNumber) {\n  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {\n    return goog.i18n.NumberFormat.NULL_UNIT_;\n  }\n\n  formattingNumber = Math.abs(formattingNumber);\n  pluralityNumber = Math.abs(pluralityNumber);\n\n  var initialPlurality = this.pluralForm_(formattingNumber);\n  // Compute the exponent from the formattingNumber, to compute the unit.\n  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);\n  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;\n  // Round both numbers based on the unit used.\n  var pluralityAttempt =\n      goog.i18n.NumberFormat.decimalShift_(pluralityNumber, -initialDivisor);\n  var pluralityRounded = this.roundNumber_(pluralityAttempt);\n  var formattingAttempt =\n      goog.i18n.NumberFormat.decimalShift_(formattingNumber, -initialDivisor);\n  var formattingRounded = this.roundNumber_(formattingAttempt);\n  // Compute the plurality of the pluralityNumber when formatted using the name\n  // units as the formattingNumber.\n  var finalPlurality =\n      this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);\n  // Get the final unit, using the rounded formatting number to get the correct\n  // unit, and the plurality computed from the pluralityNumber.\n  return this.getUnitFor_(\n      initialDivisor + this.intLog10_(formattingRounded.intValue),\n      finalPlurality);\n};\n\n\n/**\n * Get the integer base 10 logarithm of a number.\n *\n * @param {number} number The number to log.\n * @return {number} The lowest integer n such that 10^n >= number.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.intLog10_ = function(number) {\n  // Handle infinity.\n  if (!isFinite(number)) {\n    return number > 0 ? number : 0;\n  }\n  // Turns out Math.log(1000000)/Math.LN10 is strictly less than 6.\n  // TODO(nickreid): Make this use `decimalShift_` or use another more effecient\n  // string-based method.\n  var i = 0;\n  while ((number /= 10) >= 1) i++;\n  return i;\n};\n\n/**\n * Shifts `number` by `digitCount` decimal digits.\n *\n * This function corrects for rounding error that may occur when naively\n * multiplying or dividing by a power of 10. See:\n * https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems\n * Example: `1.1e27 / Math.pow(10, 12)  != 1.1e15`.\n *\n * This function does not correct for inherent limitations in the precision of\n * JavaScript numbers.\n *\n * @param {number} number The number to shift.\n * @param {number} digitCount The number of places by which to shift number.\n *     Must be an integer. May be positive or negative.\n * @return {number}\n * @private\n */\ngoog.i18n.NumberFormat.decimalShift_ = function(number, digitCount) {\n  goog.asserts.assert(\n      digitCount % 1 == 0, 'Cannot shift by fractional digits \"%s\".',\n      digitCount);\n\n  // Make sure to cover all numbers that stringify to something that doesn't\n  // look like a number.\n  if (!number || !isFinite(number) || digitCount == 0) {\n    return number;\n  }\n\n  // This method isn't efficient, but it has the exact behaviour we want without\n  // worrying about floating-point math edge cases.\n  var numParts = String(number).split('e');\n  var magnitude = parseInt(numParts[1] || 0, 10) + digitCount;\n  return parseFloat(numParts[0] + 'e' + magnitude);\n};\n\n/**\n * Rounds `number` to `decimalCount` decimal places.\n *\n * Negative values of `decimalCount` will eliminate integeral digits.\n *\n * This function corrects for rounding error that may occur when naively\n * multiplying by a power of 10.\n *\n * This function does not correct for inherent limitations in the precision of\n * JavaScript numbers.\n *\n * @param {number} number The number to round.\n * @param {number} decimalCount The number of decimal places to retain.\n *     Must be an integer. May be positive or negative.\n * @return {number}\n * @private\n */\ngoog.i18n.NumberFormat.decimalRound_ = function(number, decimalCount) {\n  goog.asserts.assert(\n      decimalCount % 1 == 0, 'Cannot round to fractional digits \"%s\".',\n      decimalCount);\n\n  if (!number || !isFinite(number)) {\n    return number;\n  }\n\n  var shift = goog.i18n.NumberFormat.decimalShift_;\n  return shift(Math.round(shift(number, decimalCount)), -decimalCount);\n};\n\n\n/**\n * Round to a certain number of significant digits.\n *\n * @param {number} number The number to round.\n * @param {number} significantDigits The number of significant digits\n *     to round to.\n * @param {number} scale Treat number as fixed point times 10^scale.\n * @return {number} The rounded number.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(\n    number, significantDigits, scale) {\n  if (!number) return number;\n\n  var digits = this.intLog10_(number);\n  var magnitude = significantDigits - digits - 1;\n\n  // Only round fraction, not (potentially shifted) integers.\n  if (magnitude < -scale) {\n    return goog.i18n.NumberFormat.decimalRound_(number, -scale);\n  } else {\n    return goog.i18n.NumberFormat.decimalRound_(number, magnitude);\n  }\n};\n\n\n/**\n * Get the plural form of a number.\n * @param {number} quantity The quantity to find plurality of.\n * @return {string} One of 'zero', 'one', 'two', 'few', 'many', 'other'.\n * @private\n */\ngoog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {\n  /* TODO: Implement */\n  return 'other';\n};\n\n\n/**\n * Checks if the currency symbol comes before the value ($12) or after (12$)\n * Handy for applications that need to have separate UI fields for the currency\n * value and symbol, especially for input: Price: [USD] [123.45]\n * The currency symbol might be a combo box, or a label.\n *\n * @return {boolean} true if currency is before value.\n */\ngoog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {\n  var posCurrSymbol = this.pattern_.indexOf('\\u00A4');  // '¤' Currency sign\n  var posPound = this.pattern_.indexOf('#');\n  var posZero = this.pattern_.indexOf('0');\n\n  // posCurrValue is the first '#' or '0' found.\n  // If none of them is found (not possible, but still),\n  // the result is true (postCurrSymbol < MAX_VALUE)\n  // That is OK, matches the en_US and ROOT locales.\n  var posCurrValue = Number.MAX_VALUE;\n  if (posPound >= 0 && posPound < posCurrValue) {\n    posCurrValue = posPound;\n  }\n  if (posZero >= 0 && posZero < posCurrValue) {\n    posCurrValue = posZero;\n  }\n\n  // No need to test, it is guaranteed that both these symbols exist.\n  // If not, we have bigger problems than this.\n  return posCurrSymbol < posCurrValue;\n};\n","~:compiled-at",1566016956939,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.i18n.numberformat.js\",\n\"lineCount\":973,\n\"mappings\":\"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\",\n\"sources\":[\"goog/i18n/numberformat.js\"],\n\"sourcesContent\":[\"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Number format/parse library with locale support.\\n */\\n\\n\\n/**\\n * Namespace for locale number format functions\\n */\\ngoog.provide('goog.i18n.NumberFormat');\\ngoog.provide('goog.i18n.NumberFormat.CurrencyStyle');\\ngoog.provide('goog.i18n.NumberFormat.Format');\\n\\ngoog.require('goog.asserts');\\ngoog.require('goog.i18n.CompactNumberFormatSymbols');\\ngoog.require('goog.i18n.NumberFormatSymbols');\\ngoog.require('goog.i18n.NumberFormatSymbols_u_nu_latn');\\ngoog.require('goog.i18n.currency');\\ngoog.require('goog.math');\\ngoog.require('goog.string');\\n\\n\\n\\n/**\\n * Constructor of NumberFormat.\\n * @param {number|string} pattern The number that indicates a predefined\\n *     number format pattern.\\n * @param {string=} opt_currency Optional international currency\\n *     code. This determines the currency code/symbol used in format/parse. If\\n *     not given, the currency code for the current locale will be used.\\n * @param {number=} opt_currencyStyle currency style, value defined in\\n *     goog.i18n.NumberFormat.CurrencyStyle. If not given, the currency style\\n *     for the current locale will be used.\\n * @param {!Object<string, string>=} opt_symbols Optional number format symbols\\n *     map, analogous to goog.i18n.NumberFormatSymbols. If present, this\\n *     overrides the symbols from the current locale, such as the percent sign\\n *     and minus sign.\\n * @constructor\\n */\\ngoog.i18n.NumberFormat = function(\\n    pattern, opt_currency, opt_currencyStyle, opt_symbols) {\\n  /** @const @private {?string} */\\n  this.intlCurrencyCode_ = opt_currency || null;\\n\\n  /** @const @private {number} */\\n  this.currencyStyle_ =\\n      opt_currencyStyle || goog.i18n.NumberFormat.CurrencyStyle.LOCAL;\\n\\n  /** @const @private {?Object<string, string>} */\\n  this.overrideNumberFormatSymbols_ = opt_symbols || null;\\n\\n  /** @private {number} */\\n  this.maximumIntegerDigits_ = 40;\\n  /** @private {number} */\\n  this.minimumIntegerDigits_ = 1;\\n  /** @private {number} */\\n  this.significantDigits_ = 0;  // invariant, <= maximumFractionDigits\\n  /** @private {number} */\\n  this.maximumFractionDigits_ = 3;  // invariant, >= minFractionDigits\\n  /** @private {number} */\\n  this.minimumFractionDigits_ = 0;\\n  /** @private {number} */\\n  this.minExponentDigits_ = 0;\\n  /** @private {boolean} */\\n  this.useSignForPositiveExponent_ = false;\\n\\n  /**\\n   * Whether to show trailing zeros in the fraction when significantDigits_ is\\n   * positive.\\n   * @private {boolean}\\n   */\\n  this.showTrailingZeros_ = false;\\n\\n  /** @private {string} */\\n  this.positivePrefix_ = '';\\n  /** @private {string} */\\n  this.positiveSuffix_ = '';\\n  /** @private {string} */\\n  this.negativePrefix_ = this.getNumberFormatSymbols_().MINUS_SIGN;\\n  /** @private {string} */\\n  this.negativeSuffix_ = '';\\n\\n  // The multiplier for use in percent, per mille, etc.\\n  /** @private {number} */\\n  this.multiplier_ = 1;\\n\\n  /**\\n   * True if the percent/permill sign of the negative pattern is expected.\\n   * @private {boolean}\\n   */\\n  this.negativePercentSignExpected_ = false;\\n\\n  /**\\n   * The grouping array is used to store the values of each number group\\n   * following left of the decimal place. For example, a number group with\\n   * goog.i18n.NumberFormat('#,##,###') should have [3,2] where 2 is the\\n   * repeated number group following a fixed number grouping of size 3.\\n   * @private {!Array<number>}\\n   */\\n  this.groupingArray_ = [];\\n\\n  /** @private {boolean} */\\n  this.decimalSeparatorAlwaysShown_ = false;\\n  /** @private {boolean} */\\n  this.useExponentialNotation_ = false;\\n  /** @private {goog.i18n.NumberFormat.CompactStyle} */\\n  this.compactStyle_ = goog.i18n.NumberFormat.CompactStyle.NONE;\\n\\n  /**\\n   * The number to base the formatting on when using compact styles, or null\\n   * if formatting should not be based on another number.\\n   * @type {?number}\\n   * @private\\n   */\\n  this.baseFormattingNumber_ = null;\\n\\n  /** @private {string} */\\n  this.pattern_;\\n\\n  if (typeof pattern == 'number') {\\n    this.applyStandardPattern_(pattern);\\n  } else {\\n    this.applyPattern_(pattern);\\n  }\\n};\\n\\n\\n/**\\n * Standard number formatting patterns.\\n * @enum {number}\\n */\\ngoog.i18n.NumberFormat.Format = {\\n  DECIMAL: 1,\\n  SCIENTIFIC: 2,\\n  PERCENT: 3,\\n  CURRENCY: 4,\\n  COMPACT_SHORT: 5,\\n  COMPACT_LONG: 6\\n};\\n\\n\\n/**\\n * Currency styles.\\n * @enum {number}\\n */\\ngoog.i18n.NumberFormat.CurrencyStyle = {\\n  LOCAL: 0,     // currency style as it is used in its circulating country.\\n  PORTABLE: 1,  // currency style that differentiate it from other popular ones.\\n  GLOBAL: 2     // currency style that is unique among all currencies.\\n};\\n\\n\\n/**\\n * Compacting styles.\\n * @enum {number}\\n */\\ngoog.i18n.NumberFormat.CompactStyle = {\\n  NONE: 0,   // Don't compact.\\n  SHORT: 1,  // Short compact form, such as 1.2B.\\n  LONG: 2    // Long compact form, such as 1.2 billion.\\n};\\n\\n\\n/**\\n * If the usage of Ascii digits should be enforced.\\n * @type {boolean}\\n * @private\\n */\\ngoog.i18n.NumberFormat.enforceAsciiDigits_ = false;\\n\\n\\n/**\\n * Set if the usage of Ascii digits in formatting should be enforced.\\n * NOTE: This function must be called before constructing NumberFormat.\\n *\\n * @param {boolean} doEnforce Boolean value about if Ascii digits should be\\n *     enforced.\\n */\\ngoog.i18n.NumberFormat.setEnforceAsciiDigits = function(doEnforce) {\\n  goog.i18n.NumberFormat.enforceAsciiDigits_ = doEnforce;\\n};\\n\\n\\n/**\\n * Return if Ascii digits is enforced.\\n * @return {boolean} If Ascii digits is enforced.\\n */\\ngoog.i18n.NumberFormat.isEnforceAsciiDigits = function() {\\n  return goog.i18n.NumberFormat.enforceAsciiDigits_;\\n};\\n\\n\\n/**\\n * Returns the current NumberFormatSymbols.\\n * @return {!Object}\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getNumberFormatSymbols_ = function() {\\n  return this.overrideNumberFormatSymbols_ ||\\n      (goog.i18n.NumberFormat.enforceAsciiDigits_ ?\\n           goog.i18n.NumberFormatSymbols_u_nu_latn :\\n           goog.i18n.NumberFormatSymbols);\\n};\\n\\n\\n/**\\n * Returns the currency code.\\n * @return {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getCurrencyCode_ = function() {\\n  return this.intlCurrencyCode_ ||\\n      this.getNumberFormatSymbols_().DEF_CURRENCY_CODE;\\n};\\n\\n\\n/**\\n * Sets minimum number of fraction digits.\\n * @param {number} min the minimum.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setMinimumFractionDigits = function(min) {\\n  if (this.significantDigits_ > 0 && min > 0) {\\n    throw new Error(\\n        'Can\\\\'t combine significant digits and minimum fraction digits');\\n  }\\n  this.minimumFractionDigits_ = min;\\n  return this;\\n};\\n\\n\\n/**\\n * Gets minimum number of fraction digits.\\n * @return {number} The number of minimum fraction digits.\\n */\\ngoog.i18n.NumberFormat.prototype.getMinimumFractionDigits = function() {\\n  return this.minimumFractionDigits_;\\n};\\n\\n\\n/**\\n * Sets maximum number of fraction digits.\\n * @param {number} max the maximum.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setMaximumFractionDigits = function(max) {\\n  if (max > 308) {\\n    // Math.pow(10, 309) becomes Infinity which breaks the logic in this class.\\n    throw new Error('Unsupported maximum fraction digits: ' + max);\\n  }\\n  this.maximumFractionDigits_ = max;\\n  return this;\\n};\\n\\n\\n/**\\n * Gets maximum number of fraction digits.\\n * @return {number} The number of maximum fraction digits.\\n */\\ngoog.i18n.NumberFormat.prototype.getMaximumFractionDigits = function() {\\n  return this.maximumFractionDigits_;\\n};\\n\\n/**\\n * Sets number of significant digits to show. Only fractions will be rounded.\\n * Regardless of the number of significant digits set, the number of fractional\\n * digits shown will always be capped by the maximum number of fractional digits\\n * set on {@link #setMaximumFractionDigits}.\\n * @param {number} number The number of significant digits to include.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setSignificantDigits = function(number) {\\n  if (this.minimumFractionDigits_ > 0 && number >= 0) {\\n    throw new Error(\\n        'Can\\\\'t combine significant digits and minimum fraction digits');\\n  }\\n  this.significantDigits_ = number;\\n  return this;\\n};\\n\\n\\n/**\\n * Gets number of significant digits to show. Only fractions will be rounded.\\n * @return {number} The number of significant digits to include.\\n */\\ngoog.i18n.NumberFormat.prototype.getSignificantDigits = function() {\\n  return this.significantDigits_;\\n};\\n\\n\\n/**\\n * Sets whether trailing fraction zeros should be shown when significantDigits_\\n * is positive. If this is true and significantDigits_ is 2, 1 will be formatted\\n * as '1.0'.\\n * @param {boolean} showTrailingZeros Whether trailing zeros should be shown.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setShowTrailingZeros = function(\\n    showTrailingZeros) {\\n  this.showTrailingZeros_ = showTrailingZeros;\\n  return this;\\n};\\n\\n\\n/**\\n * Sets a number to base the formatting on when compact style formatting is\\n * used. If this is null, the formatting should be based only on the number to\\n * be formatting.\\n *\\n * This base formatting number can be used to format the target number as\\n * another number would be formatted. For example, 100,000 is normally formatted\\n * as \\\"100K\\\" in the COMPACT_SHORT format. To instead format it as '0.1M', the\\n * base number could be set to 1,000,000 in order to force all numbers to be\\n * formatted in millions. Similarly, 1,000,000,000 would normally be formatted\\n * as '1B' and setting the base formatting number to 1,000,000, would cause it\\n * to be formatted instead as '1,000M'.\\n *\\n * @param {?number} baseFormattingNumber The number to base formatting on, or\\n * null if formatting should not be based on another number.\\n * @return {!goog.i18n.NumberFormat} Reference to this NumberFormat object.\\n */\\ngoog.i18n.NumberFormat.prototype.setBaseFormatting = function(\\n    baseFormattingNumber) {\\n  goog.asserts.assert(\\n      goog.isNull(baseFormattingNumber) || isFinite(baseFormattingNumber));\\n  this.baseFormattingNumber_ = baseFormattingNumber;\\n  return this;\\n};\\n\\n\\n/**\\n * Gets the number on which compact formatting is currently based, or null if\\n * no such number is set. See setBaseFormatting() for more information.\\n * @return {?number}\\n */\\ngoog.i18n.NumberFormat.prototype.getBaseFormatting = function() {\\n  return this.baseFormattingNumber_;\\n};\\n\\n\\n/**\\n * Apply provided pattern, result are stored in member variables.\\n *\\n * @param {string} pattern String pattern being applied.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.applyPattern_ = function(pattern) {\\n  this.pattern_ = pattern.replace(/ /g, '\\\\u00a0');\\n  var pos = [0];\\n\\n  this.positivePrefix_ = this.parseAffix_(pattern, pos);\\n  var trunkStart = pos[0];\\n  this.parseTrunk_(pattern, pos);\\n  var trunkLen = pos[0] - trunkStart;\\n  this.positiveSuffix_ = this.parseAffix_(pattern, pos);\\n  if (pos[0] < pattern.length &&\\n      pattern.charAt(pos[0]) == goog.i18n.NumberFormat.PATTERN_SEPARATOR_) {\\n    pos[0]++;\\n    if (this.multiplier_ != 1) this.negativePercentSignExpected_ = true;\\n    this.negativePrefix_ = this.parseAffix_(pattern, pos);\\n    // we assume this part is identical to positive part.\\n    // user must make sure the pattern is correctly constructed.\\n    pos[0] += trunkLen;\\n    this.negativeSuffix_ = this.parseAffix_(pattern, pos);\\n  } else {\\n    // if no negative affix specified, they share the same positive affix\\n    this.negativePrefix_ += this.positivePrefix_;\\n    this.negativeSuffix_ += this.positiveSuffix_;\\n  }\\n};\\n\\n\\n/**\\n * Apply a predefined pattern to NumberFormat object.\\n * @param {number} patternType The number that indicates a predefined number\\n *     format pattern.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.applyStandardPattern_ = function(patternType) {\\n  switch (patternType) {\\n    case goog.i18n.NumberFormat.Format.DECIMAL:\\n      this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);\\n      break;\\n    case goog.i18n.NumberFormat.Format.SCIENTIFIC:\\n      this.applyPattern_(this.getNumberFormatSymbols_().SCIENTIFIC_PATTERN);\\n      break;\\n    case goog.i18n.NumberFormat.Format.PERCENT:\\n      this.applyPattern_(this.getNumberFormatSymbols_().PERCENT_PATTERN);\\n      break;\\n    case goog.i18n.NumberFormat.Format.CURRENCY:\\n      this.applyPattern_(goog.i18n.currency.adjustPrecision(\\n          this.getNumberFormatSymbols_().CURRENCY_PATTERN,\\n          this.getCurrencyCode_()));\\n      break;\\n    case goog.i18n.NumberFormat.Format.COMPACT_SHORT:\\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.SHORT);\\n      break;\\n    case goog.i18n.NumberFormat.Format.COMPACT_LONG:\\n      this.applyCompactStyle_(goog.i18n.NumberFormat.CompactStyle.LONG);\\n      break;\\n    default:\\n      throw new Error('Unsupported pattern type.');\\n  }\\n};\\n\\n\\n/**\\n * Apply a predefined pattern for shorthand formats.\\n * @param {goog.i18n.NumberFormat.CompactStyle} style the compact style to\\n *     set defaults for.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.applyCompactStyle_ = function(style) {\\n  this.compactStyle_ = style;\\n  this.applyPattern_(this.getNumberFormatSymbols_().DECIMAL_PATTERN);\\n  this.setMinimumFractionDigits(0);\\n  this.setMaximumFractionDigits(2);\\n  this.setSignificantDigits(2);\\n};\\n\\n\\n/**\\n * Parses text string to produce a Number.\\n *\\n * This method attempts to parse text starting from position \\\"opt_pos\\\" if it\\n * is given. Otherwise the parse will start from the beginning of the text.\\n * When opt_pos presents, opt_pos will be updated to the character next to where\\n * parsing stops after the call. If an error occurs, opt_pos won't be updated.\\n *\\n * @param {string} text The string to be parsed.\\n * @param {Array<number>=} opt_pos Position to pass in and get back.\\n * @return {number} Parsed number. This throws an error if the text cannot be\\n *     parsed.\\n */\\ngoog.i18n.NumberFormat.prototype.parse = function(text, opt_pos) {\\n  var pos = opt_pos || [0];\\n\\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\\n    throw new Error('Parsing of compact numbers is unimplemented');\\n  }\\n\\n  var ret = NaN;\\n\\n  // We don't want to handle multiple kinds of space in parsing, normalize the\\n  // regular and narrow nbsp to nbsp.\\n  text = text.replace(/ |\\\\u202f/g, '\\\\u00a0');\\n\\n  var gotPositive = text.indexOf(this.positivePrefix_, pos[0]) == pos[0];\\n  var gotNegative = text.indexOf(this.negativePrefix_, pos[0]) == pos[0];\\n\\n  // check for the longest match\\n  if (gotPositive && gotNegative) {\\n    if (this.positivePrefix_.length > this.negativePrefix_.length) {\\n      gotNegative = false;\\n    } else if (this.positivePrefix_.length < this.negativePrefix_.length) {\\n      gotPositive = false;\\n    }\\n  }\\n\\n  if (gotPositive) {\\n    pos[0] += this.positivePrefix_.length;\\n  } else if (gotNegative) {\\n    pos[0] += this.negativePrefix_.length;\\n  }\\n\\n  // process digits or Inf, find decimal position\\n  if (text.indexOf(this.getNumberFormatSymbols_().INFINITY, pos[0]) == pos[0]) {\\n    pos[0] += this.getNumberFormatSymbols_().INFINITY.length;\\n    ret = Infinity;\\n  } else {\\n    ret = this.parseNumber_(text, pos);\\n  }\\n\\n  // check for suffix\\n  if (gotPositive) {\\n    if (!(text.indexOf(this.positiveSuffix_, pos[0]) == pos[0])) {\\n      return NaN;\\n    }\\n    pos[0] += this.positiveSuffix_.length;\\n  } else if (gotNegative) {\\n    if (!(text.indexOf(this.negativeSuffix_, pos[0]) == pos[0])) {\\n      return NaN;\\n    }\\n    pos[0] += this.negativeSuffix_.length;\\n  }\\n\\n  return gotNegative ? -ret : ret;\\n};\\n\\n\\n/**\\n * This function will parse a \\\"localized\\\" text into a Number. It needs to\\n * handle locale specific decimal, grouping, exponent and digits.\\n *\\n * @param {string} text The text that need to be parsed.\\n * @param {Array<number>} pos  In/out parsing position. In case of failure,\\n *    pos value won't be changed.\\n * @return {number} Number value, or NaN if nothing can be parsed.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.parseNumber_ = function(text, pos) {\\n  var sawDecimal = false;\\n  var sawExponent = false;\\n  var sawDigit = false;\\n  var exponentPos = -1;\\n  var scale = 1;\\n  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;\\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\\n  var exponentChar = this.getNumberFormatSymbols_().EXP_SYMBOL;\\n\\n  if (this.compactStyle_ != goog.i18n.NumberFormat.CompactStyle.NONE) {\\n    throw new Error('Parsing of compact style numbers is not implemented');\\n  }\\n\\n  // We don't want to handle multiple kinds of space in parsing, normalize the\\n  // narrow nbsp to nbsp.\\n  grouping = grouping.replace(/\\\\u202f/g, '\\\\u00a0');\\n\\n  var normalizedText = '';\\n  for (; pos[0] < text.length; pos[0]++) {\\n    var ch = text.charAt(pos[0]);\\n    var digit = this.getDigit_(ch);\\n    if (digit >= 0 && digit <= 9) {\\n      normalizedText += digit;\\n      sawDigit = true;\\n    } else if (ch == decimal.charAt(0)) {\\n      if (sawDecimal || sawExponent) {\\n        break;\\n      }\\n      normalizedText += '.';\\n      sawDecimal = true;\\n    } else if (\\n        ch == grouping.charAt(0) &&\\n        ('\\\\u00a0' != grouping.charAt(0) ||\\n         pos[0] + 1 < text.length &&\\n             this.getDigit_(text.charAt(pos[0] + 1)) >= 0)) {\\n      // Got a grouping character here. When grouping character is nbsp, need\\n      // to make sure the character following it is a digit.\\n      if (sawDecimal || sawExponent) {\\n        break;\\n      }\\n      continue;\\n    } else if (ch == exponentChar.charAt(0)) {\\n      if (sawExponent) {\\n        break;\\n      }\\n      normalizedText += 'E';\\n      sawExponent = true;\\n      exponentPos = pos[0];\\n    } else if (ch == '+' || ch == '-') {\\n      // Stop parsing if a '+' or '-' sign is found after digits have been found\\n      // but it's not located right after an exponent sign.\\n      if (sawDigit && exponentPos != pos[0] - 1) {\\n        break;\\n      }\\n      normalizedText += ch;\\n    } else if (\\n        this.multiplier_ == 1 &&\\n        ch == this.getNumberFormatSymbols_().PERCENT.charAt(0)) {\\n      // Parse the percent character as part of the number only when it's\\n      // not already included in the pattern.\\n      if (scale != 1) {\\n        break;\\n      }\\n      scale = 100;\\n      if (sawDigit) {\\n        pos[0]++;  // eat this character if parse end here\\n        break;\\n      }\\n    } else if (\\n        this.multiplier_ == 1 &&\\n        ch == this.getNumberFormatSymbols_().PERMILL.charAt(0)) {\\n      // Parse the permill character as part of the number only when it's\\n      // not already included in the pattern.\\n      if (scale != 1) {\\n        break;\\n      }\\n      scale = 1000;\\n      if (sawDigit) {\\n        pos[0]++;  // eat this character if parse end here\\n        break;\\n      }\\n    } else {\\n      break;\\n    }\\n  }\\n\\n  // Scale the number when the percent/permill character was included in\\n  // the pattern.\\n  if (this.multiplier_ != 1) {\\n    scale = this.multiplier_;\\n  }\\n\\n  return parseFloat(normalizedText) / scale;\\n};\\n\\n\\n/**\\n * Formats a Number to produce a string.\\n *\\n * @param {number} number The Number to be formatted.\\n * @return {string} The formatted number string.\\n */\\ngoog.i18n.NumberFormat.prototype.format = function(number) {\\n  if (isNaN(number)) {\\n    return this.getNumberFormatSymbols_().NAN;\\n  }\\n\\n  var parts = [];\\n  var baseFormattingNumber = goog.isNull(this.baseFormattingNumber_) ?\\n      number :\\n      this.baseFormattingNumber_;\\n  var unit = this.getUnitAfterRounding_(baseFormattingNumber, number);\\n  number = goog.i18n.NumberFormat.decimalShift_(number, -unit.divisorBase);\\n\\n  parts.push(unit.prefix);\\n\\n  // in icu code, it is commented that certain computation need to keep the\\n  // negative sign for 0.\\n  var isNegative = number < 0.0 || number == 0.0 && 1 / number < 0.0;\\n\\n  parts.push(isNegative ? this.negativePrefix_ : this.positivePrefix_);\\n\\n  if (!isFinite(number)) {\\n    parts.push(this.getNumberFormatSymbols_().INFINITY);\\n  } else {\\n    // convert number to non-negative value\\n    number *= isNegative ? -1 : 1;\\n\\n    number *= this.multiplier_;\\n    this.useExponentialNotation_ ?\\n        this.subformatExponential_(number, parts) :\\n        this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\\n  }\\n\\n  parts.push(isNegative ? this.negativeSuffix_ : this.positiveSuffix_);\\n  parts.push(unit.suffix);\\n\\n  return parts.join('');\\n};\\n\\n\\n/**\\n * Round a number into an integer and fractional part\\n * based on the rounding rules for this NumberFormat.\\n * @param {number} number The number to round.\\n * @return {{intValue: number, fracValue: number}} The integer and fractional\\n *     part after rounding.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.roundNumber_ = function(number) {\\n  var shift = goog.i18n.NumberFormat.decimalShift_;\\n\\n  var shiftedNumber = shift(number, this.maximumFractionDigits_);\\n  if (this.significantDigits_ > 0) {\\n    shiftedNumber = this.roundToSignificantDigits_(\\n        shiftedNumber, this.significantDigits_, this.maximumFractionDigits_);\\n  }\\n  shiftedNumber = Math.round(shiftedNumber);\\n\\n  var intValue, fracValue;\\n  if (isFinite(shiftedNumber)) {\\n    intValue = Math.floor(shift(shiftedNumber, -this.maximumFractionDigits_));\\n    fracValue = Math.floor(\\n        shiftedNumber - shift(intValue, this.maximumFractionDigits_));\\n  } else {\\n    intValue = number;\\n    fracValue = 0;\\n  }\\n  return {intValue: intValue, fracValue: fracValue};\\n};\\n\\n\\n/**\\n * Formats a number with the appropriate groupings when there are repeating\\n * digits present. Repeating digits exists when the length of the digits left\\n * of the decimal place exceeds the number of non-repeating digits.\\n *\\n * Formats a number by iterating through the integer number (intPart) from the\\n * most left of the decimal place by inserting the appropriate number grouping\\n * separator for the repeating digits until all of the repeating digits is\\n * iterated. Then iterate through the non-repeating digits by inserting the\\n * appropriate number grouping separator until all the non-repeating digits\\n * is iterated through.\\n *\\n * In the number grouping concept, anything left of the decimal\\n * place is followed by non-repeating digits and then repeating digits. If the\\n * pattern is #,##,###, then we first (from the left of the decimal place) have\\n * a non-repeating digit of size 3 followed by repeating digits of size 2\\n * separated by a thousand separator. If the length of the digits are six or\\n * more, there may be repeating digits required. For example, the value of\\n * 12345678 would format as 1,23,45,678 where the repeating digit is length 2.\\n *\\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\\n *  number including the values and separators.\\n * @param {number} zeroCode The value of the zero digit whether or not\\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\\n * @param {string} intPart The integer representation of the number to be\\n *  formatted and referenced.\\n * @param {!Array<number>} groupingArray The array of numbers to determine the\\n *  grouping of repeated and non-repeated digits.\\n * @param {number} repeatedDigitLen The length of the repeated digits left of\\n *  the non-repeating digits left of the decimal.\\n * @return {!Array<string>} Returns the resulting parts variable containing\\n *  how numbers are to be grouped and appear.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.formatNumberGroupingRepeatingDigitsParts_ =\\n    function(parts, zeroCode, intPart, groupingArray, repeatedDigitLen) {\\n  // Keep track of how much has been completed on the non repeated groups\\n  var nonRepeatedGroupCompleteCount = 0;\\n  var currentGroupSizeIndex = 0;\\n  var currentGroupSize = 0;\\n\\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\\n  var digitLen = intPart.length;\\n\\n  // There are repeating digits and non-repeating digits\\n  for (var i = 0; i < digitLen; i++) {\\n    parts.push(String.fromCharCode(zeroCode + Number(intPart.charAt(i)) * 1));\\n    if (digitLen - i > 1) {\\n      currentGroupSize = groupingArray[currentGroupSizeIndex];\\n      if (i < repeatedDigitLen) {\\n        // Process the left side (the repeated number groups)\\n        var repeatedDigitIndex = repeatedDigitLen - i;\\n        // Edge case if there's a number grouping asking for \\\"1\\\" group at\\n        // a time; otherwise, if the remainder is 1, there's the separator\\n        if (currentGroupSize === 1 ||\\n            (currentGroupSize > 0 &&\\n             (repeatedDigitIndex % currentGroupSize) === 1)) {\\n          parts.push(grouping);\\n        }\\n      } else if (currentGroupSizeIndex < groupingArray.length) {\\n        // Process the right side (the non-repeated fixed number groups)\\n        if (i === repeatedDigitLen) {\\n          // Increase the group index because a separator\\n          // has previously added in the earlier logic\\n          currentGroupSizeIndex += 1;\\n        } else if (\\n            currentGroupSize ===\\n            i - repeatedDigitLen - nonRepeatedGroupCompleteCount + 1) {\\n          // Otherwise, just iterate to the right side and\\n          // add a separator once the length matches to the expected\\n          parts.push(grouping);\\n          // Keep track of what has been completed on the right\\n          nonRepeatedGroupCompleteCount += currentGroupSize;\\n          currentGroupSizeIndex += 1;  // Get to the next number grouping\\n        }\\n      }\\n    }\\n  }\\n  return parts;\\n};\\n\\n\\n/**\\n * Formats a number with the appropriate groupings when there are no repeating\\n * digits present. Non-repeating digits exists when the length of the digits\\n * left of the decimal place is equal or lesser than the length of\\n * non-repeating digits.\\n *\\n * Formats a number by iterating through the integer number (intPart) from the\\n * right most non-repeating number group of the decimal place. For each group,\\n * inserting the appropriate number grouping separator for the non-repeating\\n * digits until the number is completely iterated.\\n *\\n * In the number grouping concept, anything left of the decimal\\n * place is followed by non-repeating digits and then repeating digits. If the\\n * pattern is #,##,###, then we first (from the left of the decimal place) have\\n * a non-repeating digit of size 3 followed by repeating digits of size 2\\n * separated by a thousand separator. If the length of the digits are five or\\n * less, there won't be any repeating digits required. For example, the value\\n * of 12345 would be formatted as 12,345 where the non-repeating digit is of\\n * length 3.\\n *\\n * @param {!Array<string>} parts An array to build the 'parts' of the formatted\\n *  number including the values and separators.\\n * @param {number} zeroCode The value of the zero digit whether or not\\n *  goog.i18n.NumberFormat.enforceAsciiDigits_ is enforced.\\n * @param {string} intPart The integer representation of the number to be\\n *  formatted and referenced.\\n * @param {!Array<number>} groupingArray The array of numbers to determine the\\n *  grouping of repeated and non-repeated digits.\\n * @return {!Array<string>} Returns the resulting parts variable containing\\n *  how numbers are to be grouped and appear.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.formatNumberGroupingNonRepeatingDigitsParts_ =\\n    function(parts, zeroCode, intPart, groupingArray) {\\n  // Keep track of how much has been completed on the non repeated groups\\n  var grouping = this.getNumberFormatSymbols_().GROUP_SEP;\\n  var currentGroupSizeIndex;\\n  var currentGroupSize = 0;\\n  var digitLenLeft = intPart.length;\\n  var rightToLeftParts = [];\\n\\n  // Start from the right most non-repeating group and work inwards\\n  for (currentGroupSizeIndex = groupingArray.length - 1;\\n       currentGroupSizeIndex >= 0 && digitLenLeft > 0;\\n       currentGroupSizeIndex--) {\\n    currentGroupSize = groupingArray[currentGroupSizeIndex];\\n    // Iterate from the right most digit\\n    for (var rightDigitIndex = 0; rightDigitIndex < currentGroupSize &&\\n         ((digitLenLeft - rightDigitIndex - 1) >= 0);\\n         rightDigitIndex++) {\\n      rightToLeftParts.push(String.fromCharCode(\\n          zeroCode +\\n          Number(intPart.charAt(digitLenLeft - rightDigitIndex - 1)) * 1));\\n    }\\n    // Update the number of digits left\\n    digitLenLeft -= currentGroupSize;\\n    if (digitLenLeft > 0) {\\n      rightToLeftParts.push(grouping);\\n    }\\n  }\\n  // Reverse and push onto the remaining parts\\n  parts.push.apply(parts, rightToLeftParts.reverse());\\n\\n  return parts;\\n};\\n\\n\\n/**\\n * Formats a Number in fraction format.\\n *\\n * @param {number} number\\n * @param {number} minIntDigits Minimum integer digits.\\n * @param {Array<string>} parts\\n *     This array holds the pieces of formatted string.\\n *     This function will add its formatted pieces to the array.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.subformatFixed_ = function(\\n    number, minIntDigits, parts) {\\n  if (this.minimumFractionDigits_ > this.maximumFractionDigits_) {\\n    throw new Error('Min value must be less than max value');\\n  }\\n\\n  if (!parts) {\\n    parts = [];\\n  }\\n\\n  var rounded = this.roundNumber_(number);\\n  var intValue = rounded.intValue;\\n  var fracValue = rounded.fracValue;\\n\\n  var numIntDigits = (intValue == 0) ? 0 : this.intLog10_(intValue) + 1;\\n  var fractionPresent = this.minimumFractionDigits_ > 0 || fracValue > 0 ||\\n      (this.showTrailingZeros_ && numIntDigits < this.significantDigits_);\\n  var minimumFractionDigits = this.minimumFractionDigits_;\\n  if (fractionPresent) {\\n    if (this.showTrailingZeros_ && this.significantDigits_ > 0) {\\n      minimumFractionDigits = this.significantDigits_ - numIntDigits;\\n    } else {\\n      minimumFractionDigits = this.minimumFractionDigits_;\\n    }\\n  }\\n\\n  var intPart = '';\\n  var translatableInt = intValue;\\n  while (translatableInt > 1E20) {\\n    // here it goes beyond double precision, add '0' make it look better\\n    intPart = '0' + intPart;\\n    translatableInt =\\n        Math.round(goog.i18n.NumberFormat.decimalShift_(translatableInt, -1));\\n  }\\n  intPart = translatableInt + intPart;\\n\\n  var decimal = this.getNumberFormatSymbols_().DECIMAL_SEP;\\n  var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\\n  var digitLen = intPart.length;\\n  var nonRepeatedGroupCount = 0;\\n\\n  if (intValue > 0 || minIntDigits > 0) {\\n    for (var i = digitLen; i < minIntDigits; i++) {\\n      parts.push(String.fromCharCode(zeroCode));\\n    }\\n\\n    // If there's more than 1 number grouping,\\n    // figure out the length of the non-repeated groupings (on the right)\\n    if (this.groupingArray_.length >= 2) {\\n      for (var j = 1; j < this.groupingArray_.length; j++) {\\n        nonRepeatedGroupCount += this.groupingArray_[j];\\n      }\\n    }\\n\\n    // Anything left of the fixed number grouping is repeated,\\n    // figure out the length of repeated groupings (on the left)\\n    var repeatedDigitLen = digitLen - nonRepeatedGroupCount;\\n    if (repeatedDigitLen > 0) {\\n      // There are repeating digits and non-repeating digits\\n      parts = this.formatNumberGroupingRepeatingDigitsParts_(\\n          parts, zeroCode, intPart, this.groupingArray_, repeatedDigitLen);\\n    } else {\\n      // There are no repeating digits and only non-repeating digits\\n      parts = this.formatNumberGroupingNonRepeatingDigitsParts_(\\n          parts, zeroCode, intPart, this.groupingArray_);\\n    }\\n  } else if (!fractionPresent) {\\n    // If there is no fraction present, and we haven't printed any\\n    // integer digits, then print a zero.\\n    parts.push(String.fromCharCode(zeroCode));\\n  }\\n\\n  // Output the decimal separator if we always do so.\\n  if (this.decimalSeparatorAlwaysShown_ || fractionPresent) {\\n    parts.push(decimal);\\n  }\\n\\n  var fracPart = String(fracValue);\\n  // Handle case where fracPart is in scientific notation.\\n  var fracPartSplit = fracPart.split('e+');\\n  if (fracPartSplit.length == 2) {\\n    // Only keep significant digits.\\n    var floatFrac = parseFloat(fracPartSplit[0]);\\n    fracPart = String(\\n        this.roundToSignificantDigits_(floatFrac, this.significantDigits_, 1));\\n    fracPart = fracPart.replace('.', '');\\n    // Append zeroes based on the exponent.\\n    var exp = parseInt(fracPartSplit[1], 10);\\n    fracPart += goog.string.repeat('0', exp - fracPart.length + 1);\\n  }\\n\\n  // Add Math.pow(10, this.maximumFractionDigits) to fracPart. Uses string ops\\n  // to avoid complexity with scientific notation and overflows.\\n  if (this.maximumFractionDigits_ + 1 > fracPart.length) {\\n    var zeroesToAdd = this.maximumFractionDigits_ - fracPart.length;\\n    fracPart = '1' + goog.string.repeat('0', zeroesToAdd) + fracPart;\\n  }\\n\\n  var fracLen = fracPart.length;\\n  while (fracPart.charAt(fracLen - 1) == '0' &&\\n         fracLen > minimumFractionDigits + 1) {\\n    fracLen--;\\n  }\\n\\n  for (var i = 1; i < fracLen; i++) {\\n    parts.push(String.fromCharCode(zeroCode + Number(fracPart.charAt(i)) * 1));\\n  }\\n};\\n\\n\\n/**\\n * Formats exponent part of a Number.\\n *\\n * @param {number} exponent Exponential value.\\n * @param {Array<string>} parts The array that holds the pieces of formatted\\n *     string. This function will append more formatted pieces to the array.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.addExponentPart_ = function(exponent, parts) {\\n  parts.push(this.getNumberFormatSymbols_().EXP_SYMBOL);\\n\\n  if (exponent < 0) {\\n    exponent = -exponent;\\n    parts.push(this.getNumberFormatSymbols_().MINUS_SIGN);\\n  } else if (this.useSignForPositiveExponent_) {\\n    parts.push(this.getNumberFormatSymbols_().PLUS_SIGN);\\n  }\\n\\n  var exponentDigits = '' + exponent;\\n  var zeroChar = this.getNumberFormatSymbols_().ZERO_DIGIT;\\n  for (var i = exponentDigits.length; i < this.minExponentDigits_; i++) {\\n    parts.push(zeroChar);\\n  }\\n  parts.push(exponentDigits);\\n};\\n\\n/**\\n * Returns the mantissa for the given value and its exponent.\\n *\\n * @param {number} value\\n * @param {number} exponent\\n * @return {number}\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getMantissa_ = function(value, exponent) {\\n  return goog.i18n.NumberFormat.decimalShift_(value, -exponent);\\n};\\n\\n/**\\n * Formats Number in exponential format.\\n *\\n * @param {number} number Value need to be formatted.\\n * @param {Array<string>} parts The array that holds the pieces of formatted\\n *     string. This function will append more formatted pieces to the array.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.subformatExponential_ = function(\\n    number, parts) {\\n  if (number == 0.0) {\\n    this.subformatFixed_(number, this.minimumIntegerDigits_, parts);\\n    this.addExponentPart_(0, parts);\\n    return;\\n  }\\n\\n  var exponent = goog.math.safeFloor(Math.log(number) / Math.log(10));\\n  number = this.getMantissa_(number, exponent);\\n\\n  var minIntDigits = this.minimumIntegerDigits_;\\n  if (this.maximumIntegerDigits_ > 1 &&\\n      this.maximumIntegerDigits_ > this.minimumIntegerDigits_) {\\n    // A repeating range is defined; adjust to it as follows.\\n    // If repeat == 3, we have 6,5,4=>3; 3,2,1=>0; 0,-1,-2=>-3;\\n    // -3,-4,-5=>-6, etc. This takes into account that the\\n    // exponent we have here is off by one from what we expect;\\n    // it is for the format 0.MMMMMx10^n.\\n    var remainder = exponent % this.maximumIntegerDigits_;\\n    if (remainder < 0) {\\n      remainder = this.maximumIntegerDigits_ + remainder;\\n    }\\n\\n    number = goog.i18n.NumberFormat.decimalShift_(number, remainder);\\n    exponent -= remainder;\\n\\n    minIntDigits = 1;\\n  } else {\\n    // No repeating range is defined; use minimum integer digits.\\n    if (this.minimumIntegerDigits_ < 1) {\\n      exponent++;\\n      number = goog.i18n.NumberFormat.decimalShift_(number, -1);\\n    } else {\\n      exponent -= this.minimumIntegerDigits_ - 1;\\n      number = goog.i18n.NumberFormat.decimalShift_(\\n          number, this.minimumIntegerDigits_ - 1);\\n    }\\n  }\\n  this.subformatFixed_(number, minIntDigits, parts);\\n  this.addExponentPart_(exponent, parts);\\n};\\n\\n\\n/**\\n * Returns the digit value of current character. The character could be either\\n * '0' to '9', or a locale specific digit.\\n *\\n * @param {string} ch Character that represents a digit.\\n * @return {number} The digit value, or -1 on error.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getDigit_ = function(ch) {\\n  var code = ch.charCodeAt(0);\\n  // between '0' to '9'\\n  if (48 <= code && code < 58) {\\n    return code - 48;\\n  } else {\\n    var zeroCode = this.getNumberFormatSymbols_().ZERO_DIGIT.charCodeAt(0);\\n    return zeroCode <= code && code < zeroCode + 10 ? code - zeroCode : -1;\\n  }\\n};\\n\\n\\n// ----------------------------------------------------------------------\\n// CONSTANTS\\n// ----------------------------------------------------------------------\\n// Constants for characters used in programmatic (unlocalized) patterns.\\n/**\\n * A zero digit character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_ = '0';\\n\\n\\n/**\\n * A grouping separator character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_ = ',';\\n\\n\\n/**\\n * A decimal separator character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_ = '.';\\n\\n\\n/**\\n * A per mille character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_PER_MILLE_ = '\\\\u2030';\\n\\n\\n/**\\n * A percent character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_PERCENT_ = '%';\\n\\n\\n/**\\n * A digit character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_DIGIT_ = '#';\\n\\n\\n/**\\n * A separator character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_SEPARATOR_ = ';';\\n\\n\\n/**\\n * An exponent character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_EXPONENT_ = 'E';\\n\\n\\n/**\\n * A plus character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_PLUS_ = '+';\\n\\n\\n/**\\n * A generic currency sign character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_ = '\\\\u00A4';\\n\\n\\n/**\\n * A quote character.\\n * @type {string}\\n * @private\\n */\\ngoog.i18n.NumberFormat.QUOTE_ = '\\\\'';\\n\\n\\n/**\\n * Parses affix part of pattern.\\n *\\n * @param {string} pattern Pattern string that need to be parsed.\\n * @param {Array<number>} pos One element position array to set and receive\\n *     parsing position.\\n *\\n * @return {string} Affix received from parsing.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.parseAffix_ = function(pattern, pos) {\\n  var affix = '';\\n  var inQuote = false;\\n  var len = pattern.length;\\n\\n  for (; pos[0] < len; pos[0]++) {\\n    var ch = pattern.charAt(pos[0]);\\n    if (ch == goog.i18n.NumberFormat.QUOTE_) {\\n      if (pos[0] + 1 < len &&\\n          pattern.charAt(pos[0] + 1) == goog.i18n.NumberFormat.QUOTE_) {\\n        pos[0]++;\\n        affix += '\\\\'';  // 'don''t'\\n      } else {\\n        inQuote = !inQuote;\\n      }\\n      continue;\\n    }\\n\\n    if (inQuote) {\\n      affix += ch;\\n    } else {\\n      switch (ch) {\\n        case goog.i18n.NumberFormat.PATTERN_DIGIT_:\\n        case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\\n        case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\\n        case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\\n        case goog.i18n.NumberFormat.PATTERN_SEPARATOR_:\\n          return affix;\\n        case goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_:\\n          if ((pos[0] + 1) < len &&\\n              pattern.charAt(pos[0] + 1) ==\\n                  goog.i18n.NumberFormat.PATTERN_CURRENCY_SIGN_) {\\n            pos[0]++;\\n            affix += this.getCurrencyCode_();\\n          } else {\\n            switch (this.currencyStyle_) {\\n              case goog.i18n.NumberFormat.CurrencyStyle.LOCAL:\\n                affix += goog.i18n.currency.getLocalCurrencySign(\\n                    this.getCurrencyCode_());\\n                break;\\n              case goog.i18n.NumberFormat.CurrencyStyle.GLOBAL:\\n                affix += goog.i18n.currency.getGlobalCurrencySign(\\n                    this.getCurrencyCode_());\\n                break;\\n              case goog.i18n.NumberFormat.CurrencyStyle.PORTABLE:\\n                affix += goog.i18n.currency.getPortableCurrencySign(\\n                    this.getCurrencyCode_());\\n                break;\\n              default:\\n                break;\\n            }\\n          }\\n          break;\\n        case goog.i18n.NumberFormat.PATTERN_PERCENT_:\\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\\n            throw new Error('Too many percent/permill');\\n          } else if (\\n              this.negativePercentSignExpected_ && this.multiplier_ != 100) {\\n            throw new Error('Inconsistent use of percent/permill characters');\\n          }\\n          this.multiplier_ = 100;\\n          this.negativePercentSignExpected_ = false;\\n          affix += this.getNumberFormatSymbols_().PERCENT;\\n          break;\\n        case goog.i18n.NumberFormat.PATTERN_PER_MILLE_:\\n          if (!this.negativePercentSignExpected_ && this.multiplier_ != 1) {\\n            throw new Error('Too many percent/permill');\\n          } else if (\\n              this.negativePercentSignExpected_ && this.multiplier_ != 1000) {\\n            throw new Error('Inconsistent use of percent/permill characters');\\n          }\\n          this.multiplier_ = 1000;\\n          this.negativePercentSignExpected_ = false;\\n          affix += this.getNumberFormatSymbols_().PERMILL;\\n          break;\\n        default:\\n          affix += ch;\\n      }\\n    }\\n  }\\n\\n  return affix;\\n};\\n\\n\\n/**\\n * Parses the trunk part of a pattern.\\n *\\n * @param {string} pattern Pattern string that need to be parsed.\\n * @param {Array<number>} pos One element position array to set and receive\\n *     parsing position.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.parseTrunk_ = function(pattern, pos) {\\n  var decimalPos = -1;\\n  var digitLeftCount = 0;\\n  var zeroDigitCount = 0;\\n  var digitRightCount = 0;\\n  var groupingCount = -1;\\n  var len = pattern.length;\\n  for (var loop = true; pos[0] < len && loop; pos[0]++) {\\n    var ch = pattern.charAt(pos[0]);\\n    switch (ch) {\\n      case goog.i18n.NumberFormat.PATTERN_DIGIT_:\\n        if (zeroDigitCount > 0) {\\n          digitRightCount++;\\n        } else {\\n          digitLeftCount++;\\n        }\\n        if (groupingCount >= 0 && decimalPos < 0) {\\n          groupingCount++;\\n        }\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_:\\n        if (digitRightCount > 0) {\\n          throw new Error('Unexpected \\\"0\\\" in pattern \\\"' + pattern + '\\\"');\\n        }\\n        zeroDigitCount++;\\n        if (groupingCount >= 0 && decimalPos < 0) {\\n          groupingCount++;\\n        }\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_GROUPING_SEPARATOR_:\\n        if (groupingCount > 0) {\\n          this.groupingArray_.push(groupingCount);\\n        }\\n        groupingCount = 0;\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_DECIMAL_SEPARATOR_:\\n        if (decimalPos >= 0) {\\n          throw new Error(\\n              'Multiple decimal separators in pattern \\\"' + pattern + '\\\"');\\n        }\\n        decimalPos = digitLeftCount + zeroDigitCount + digitRightCount;\\n        break;\\n      case goog.i18n.NumberFormat.PATTERN_EXPONENT_:\\n        if (this.useExponentialNotation_) {\\n          throw new Error(\\n              'Multiple exponential symbols in pattern \\\"' + pattern + '\\\"');\\n        }\\n        this.useExponentialNotation_ = true;\\n        this.minExponentDigits_ = 0;\\n\\n        // exponent pattern can have a optional '+'.\\n        if ((pos[0] + 1) < len &&\\n            pattern.charAt(pos[0] + 1) ==\\n                goog.i18n.NumberFormat.PATTERN_PLUS_) {\\n          pos[0]++;\\n          this.useSignForPositiveExponent_ = true;\\n        }\\n\\n        // Use lookahead to parse out the exponential part\\n        // of the pattern, then jump into phase 2.\\n        while ((pos[0] + 1) < len &&\\n               pattern.charAt(pos[0] + 1) ==\\n                   goog.i18n.NumberFormat.PATTERN_ZERO_DIGIT_) {\\n          pos[0]++;\\n          this.minExponentDigits_++;\\n        }\\n\\n        if ((digitLeftCount + zeroDigitCount) < 1 ||\\n            this.minExponentDigits_ < 1) {\\n          throw new Error('Malformed exponential pattern \\\"' + pattern + '\\\"');\\n        }\\n        loop = false;\\n        break;\\n      default:\\n        pos[0]--;\\n        loop = false;\\n        break;\\n    }\\n  }\\n\\n  if (zeroDigitCount == 0 && digitLeftCount > 0 && decimalPos >= 0) {\\n    // Handle '###.###' and '###.' and '.###'\\n    var n = decimalPos;\\n    if (n == 0) {  // Handle '.###'\\n      n++;\\n    }\\n    digitRightCount = digitLeftCount - n;\\n    digitLeftCount = n - 1;\\n    zeroDigitCount = 1;\\n  }\\n\\n  // Do syntax checking on the digits.\\n  if (decimalPos < 0 && digitRightCount > 0 ||\\n      decimalPos >= 0 && (decimalPos < digitLeftCount ||\\n                          decimalPos > digitLeftCount + zeroDigitCount) ||\\n      groupingCount == 0) {\\n    throw new Error('Malformed pattern \\\"' + pattern + '\\\"');\\n  }\\n  var totalDigits = digitLeftCount + zeroDigitCount + digitRightCount;\\n\\n  this.maximumFractionDigits_ = decimalPos >= 0 ? totalDigits - decimalPos : 0;\\n  if (decimalPos >= 0) {\\n    this.minimumFractionDigits_ = digitLeftCount + zeroDigitCount - decimalPos;\\n    if (this.minimumFractionDigits_ < 0) {\\n      this.minimumFractionDigits_ = 0;\\n    }\\n  }\\n\\n  // The effectiveDecimalPos is the position the decimal is at or would be at\\n  // if there is no decimal. Note that if decimalPos<0, then digitTotalCount ==\\n  // digitLeftCount + zeroDigitCount.\\n  var effectiveDecimalPos = decimalPos >= 0 ? decimalPos : totalDigits;\\n  this.minimumIntegerDigits_ = effectiveDecimalPos - digitLeftCount;\\n  if (this.useExponentialNotation_) {\\n    this.maximumIntegerDigits_ = digitLeftCount + this.minimumIntegerDigits_;\\n\\n    // in exponential display, we need to at least show something.\\n    if (this.maximumFractionDigits_ == 0 && this.minimumIntegerDigits_ == 0) {\\n      this.minimumIntegerDigits_ = 1;\\n    }\\n  }\\n\\n  // Add another number grouping at the end\\n  this.groupingArray_.push(Math.max(0, groupingCount));\\n  this.decimalSeparatorAlwaysShown_ =\\n      decimalPos == 0 || decimalPos == totalDigits;\\n};\\n\\n\\n/**\\n * Alias for the compact format 'unit' object.\\n * @typedef {{\\n *     prefix: string,\\n *     suffix: string,\\n *     divisorBase: number\\n * }}\\n */\\ngoog.i18n.NumberFormat.CompactNumberUnit;\\n\\n\\n/**\\n * The empty unit, corresponding to a base of 0.\\n * @private {!goog.i18n.NumberFormat.CompactNumberUnit}\\n */\\ngoog.i18n.NumberFormat.NULL_UNIT_ = {\\n  prefix: '',\\n  suffix: '',\\n  divisorBase: 0\\n};\\n\\n\\n/**\\n * Get compact unit for a certain number of digits\\n *\\n * @param {number} base The number of digits to get the unit for.\\n * @param {string} plurality The plurality of the number.\\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The compact unit.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getUnitFor_ = function(base, plurality) {\\n  var table = this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.SHORT ?\\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN :\\n      goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_LONG_PATTERN;\\n\\n  if (!goog.isDefAndNotNull(table)) {\\n    table = goog.i18n.CompactNumberFormatSymbols.COMPACT_DECIMAL_SHORT_PATTERN;\\n  }\\n\\n  if (base < 3) {\\n    return goog.i18n.NumberFormat.NULL_UNIT_;\\n  } else {\\n    var shift = goog.i18n.NumberFormat.decimalShift_;\\n\\n    base = Math.min(14, base);\\n    var patterns = table[shift(1, base)];\\n    var previousNonNullBase = base - 1;\\n    while (!patterns && previousNonNullBase >= 3) {\\n      patterns = table[shift(1, previousNonNullBase)];\\n      previousNonNullBase--;\\n    }\\n    if (!patterns) {\\n      return goog.i18n.NumberFormat.NULL_UNIT_;\\n    }\\n\\n    var pattern = patterns[plurality];\\n    if (!pattern || pattern == '0') {\\n      return goog.i18n.NumberFormat.NULL_UNIT_;\\n    }\\n\\n    var parts = /([^0]*)(0+)(.*)/.exec(pattern);\\n    if (!parts) {\\n      return goog.i18n.NumberFormat.NULL_UNIT_;\\n    }\\n\\n    return {\\n      prefix: parts[1],\\n      suffix: parts[3],\\n      divisorBase: (previousNonNullBase + 1) - (parts[2].length - 1)\\n    };\\n  }\\n};\\n\\n\\n/**\\n * Get the compact unit divisor, accounting for rounding of the quantity.\\n *\\n * @param {number} formattingNumber The number to base the formatting on. The\\n *     unit will be calculated from this number.\\n * @param {number} pluralityNumber The number to use for calculating the\\n *     plurality.\\n * @return {!goog.i18n.NumberFormat.CompactNumberUnit} The unit after rounding.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.getUnitAfterRounding_ = function(\\n    formattingNumber, pluralityNumber) {\\n  if (this.compactStyle_ == goog.i18n.NumberFormat.CompactStyle.NONE) {\\n    return goog.i18n.NumberFormat.NULL_UNIT_;\\n  }\\n\\n  formattingNumber = Math.abs(formattingNumber);\\n  pluralityNumber = Math.abs(pluralityNumber);\\n\\n  var initialPlurality = this.pluralForm_(formattingNumber);\\n  // Compute the exponent from the formattingNumber, to compute the unit.\\n  var base = formattingNumber <= 1 ? 0 : this.intLog10_(formattingNumber);\\n  var initialDivisor = this.getUnitFor_(base, initialPlurality).divisorBase;\\n  // Round both numbers based on the unit used.\\n  var pluralityAttempt =\\n      goog.i18n.NumberFormat.decimalShift_(pluralityNumber, -initialDivisor);\\n  var pluralityRounded = this.roundNumber_(pluralityAttempt);\\n  var formattingAttempt =\\n      goog.i18n.NumberFormat.decimalShift_(formattingNumber, -initialDivisor);\\n  var formattingRounded = this.roundNumber_(formattingAttempt);\\n  // Compute the plurality of the pluralityNumber when formatted using the name\\n  // units as the formattingNumber.\\n  var finalPlurality =\\n      this.pluralForm_(pluralityRounded.intValue + pluralityRounded.fracValue);\\n  // Get the final unit, using the rounded formatting number to get the correct\\n  // unit, and the plurality computed from the pluralityNumber.\\n  return this.getUnitFor_(\\n      initialDivisor + this.intLog10_(formattingRounded.intValue),\\n      finalPlurality);\\n};\\n\\n\\n/**\\n * Get the integer base 10 logarithm of a number.\\n *\\n * @param {number} number The number to log.\\n * @return {number} The lowest integer n such that 10^n >= number.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.intLog10_ = function(number) {\\n  // Handle infinity.\\n  if (!isFinite(number)) {\\n    return number > 0 ? number : 0;\\n  }\\n  // Turns out Math.log(1000000)/Math.LN10 is strictly less than 6.\\n  // TODO(nickreid): Make this use `decimalShift_` or use another more effecient\\n  // string-based method.\\n  var i = 0;\\n  while ((number /= 10) >= 1) i++;\\n  return i;\\n};\\n\\n/**\\n * Shifts `number` by `digitCount` decimal digits.\\n *\\n * This function corrects for rounding error that may occur when naively\\n * multiplying or dividing by a power of 10. See:\\n * https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems\\n * Example: `1.1e27 / Math.pow(10, 12)  != 1.1e15`.\\n *\\n * This function does not correct for inherent limitations in the precision of\\n * JavaScript numbers.\\n *\\n * @param {number} number The number to shift.\\n * @param {number} digitCount The number of places by which to shift number.\\n *     Must be an integer. May be positive or negative.\\n * @return {number}\\n * @private\\n */\\ngoog.i18n.NumberFormat.decimalShift_ = function(number, digitCount) {\\n  goog.asserts.assert(\\n      digitCount % 1 == 0, 'Cannot shift by fractional digits \\\"%s\\\".',\\n      digitCount);\\n\\n  // Make sure to cover all numbers that stringify to something that doesn't\\n  // look like a number.\\n  if (!number || !isFinite(number) || digitCount == 0) {\\n    return number;\\n  }\\n\\n  // This method isn't efficient, but it has the exact behaviour we want without\\n  // worrying about floating-point math edge cases.\\n  var numParts = String(number).split('e');\\n  var magnitude = parseInt(numParts[1] || 0, 10) + digitCount;\\n  return parseFloat(numParts[0] + 'e' + magnitude);\\n};\\n\\n/**\\n * Rounds `number` to `decimalCount` decimal places.\\n *\\n * Negative values of `decimalCount` will eliminate integeral digits.\\n *\\n * This function corrects for rounding error that may occur when naively\\n * multiplying by a power of 10.\\n *\\n * This function does not correct for inherent limitations in the precision of\\n * JavaScript numbers.\\n *\\n * @param {number} number The number to round.\\n * @param {number} decimalCount The number of decimal places to retain.\\n *     Must be an integer. May be positive or negative.\\n * @return {number}\\n * @private\\n */\\ngoog.i18n.NumberFormat.decimalRound_ = function(number, decimalCount) {\\n  goog.asserts.assert(\\n      decimalCount % 1 == 0, 'Cannot round to fractional digits \\\"%s\\\".',\\n      decimalCount);\\n\\n  if (!number || !isFinite(number)) {\\n    return number;\\n  }\\n\\n  var shift = goog.i18n.NumberFormat.decimalShift_;\\n  return shift(Math.round(shift(number, decimalCount)), -decimalCount);\\n};\\n\\n\\n/**\\n * Round to a certain number of significant digits.\\n *\\n * @param {number} number The number to round.\\n * @param {number} significantDigits The number of significant digits\\n *     to round to.\\n * @param {number} scale Treat number as fixed point times 10^scale.\\n * @return {number} The rounded number.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.roundToSignificantDigits_ = function(\\n    number, significantDigits, scale) {\\n  if (!number) return number;\\n\\n  var digits = this.intLog10_(number);\\n  var magnitude = significantDigits - digits - 1;\\n\\n  // Only round fraction, not (potentially shifted) integers.\\n  if (magnitude < -scale) {\\n    return goog.i18n.NumberFormat.decimalRound_(number, -scale);\\n  } else {\\n    return goog.i18n.NumberFormat.decimalRound_(number, magnitude);\\n  }\\n};\\n\\n\\n/**\\n * Get the plural form of a number.\\n * @param {number} quantity The quantity to find plurality of.\\n * @return {string} One of 'zero', 'one', 'two', 'few', 'many', 'other'.\\n * @private\\n */\\ngoog.i18n.NumberFormat.prototype.pluralForm_ = function(quantity) {\\n  /* TODO: Implement */\\n  return 'other';\\n};\\n\\n\\n/**\\n * Checks if the currency symbol comes before the value ($12) or after (12$)\\n * Handy for applications that need to have separate UI fields for the currency\\n * value and symbol, especially for input: Price: [USD] [123.45]\\n * The currency symbol might be a combo box, or a label.\\n *\\n * @return {boolean} true if currency is before value.\\n */\\ngoog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue = function() {\\n  var posCurrSymbol = this.pattern_.indexOf('\\\\u00A4');  // '\\u00a4' Currency sign\\n  var posPound = this.pattern_.indexOf('#');\\n  var posZero = this.pattern_.indexOf('0');\\n\\n  // posCurrValue is the first '#' or '0' found.\\n  // If none of them is found (not possible, but still),\\n  // the result is true (postCurrSymbol < MAX_VALUE)\\n  // That is OK, matches the en_US and ROOT locales.\\n  var posCurrValue = Number.MAX_VALUE;\\n  if (posPound >= 0 && posPound < posCurrValue) {\\n    posCurrValue = posPound;\\n  }\\n  if (posZero >= 0 && posZero < posCurrValue) {\\n    posCurrValue = posZero;\\n  }\\n\\n  // No need to test, it is guaranteed that both these symbols exist.\\n  // If not, we have bigger problems than this.\\n  return posCurrSymbol < posCurrValue;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"i18n\",\"NumberFormat\",\"goog.i18n.NumberFormat\",\"pattern\",\"opt_currency\",\"opt_currencyStyle\",\"opt_symbols\",\"intlCurrencyCode_\",\"currencyStyle_\",\"CurrencyStyle\",\"LOCAL\",\"overrideNumberFormatSymbols_\",\"maximumIntegerDigits_\",\"minimumIntegerDigits_\",\"significantDigits_\",\"maximumFractionDigits_\",\"minimumFractionDigits_\",\"minExponentDigits_\",\"useSignForPositiveExponent_\",\"showTrailingZeros_\",\"positivePrefix_\",\"positiveSuffix_\",\"negativePrefix_\",\"getNumberFormatSymbols_\",\"MINUS_SIGN\",\"negativeSuffix_\",\"multiplier_\",\"negativePercentSignExpected_\",\"groupingArray_\",\"decimalSeparatorAlwaysShown_\",\"useExponentialNotation_\",\"compactStyle_\",\"CompactStyle\",\"NONE\",\"baseFormattingNumber_\",\"pattern_\",\"applyStandardPattern_\",\"applyPattern_\",\"Format\",\"DECIMAL\",\"SCIENTIFIC\",\"PERCENT\",\"CURRENCY\",\"COMPACT_SHORT\",\"COMPACT_LONG\",\"PORTABLE\",\"GLOBAL\",\"SHORT\",\"LONG\",\"enforceAsciiDigits_\",\"setEnforceAsciiDigits\",\"goog.i18n.NumberFormat.setEnforceAsciiDigits\",\"doEnforce\",\"isEnforceAsciiDigits\",\"goog.i18n.NumberFormat.isEnforceAsciiDigits\",\"prototype\",\"goog.i18n.NumberFormat.prototype.getNumberFormatSymbols_\",\"NumberFormatSymbols_u_nu_latn\",\"NumberFormatSymbols\",\"getCurrencyCode_\",\"goog.i18n.NumberFormat.prototype.getCurrencyCode_\",\"DEF_CURRENCY_CODE\",\"setMinimumFractionDigits\",\"goog.i18n.NumberFormat.prototype.setMinimumFractionDigits\",\"min\",\"Error\",\"getMinimumFractionDigits\",\"goog.i18n.NumberFormat.prototype.getMinimumFractionDigits\",\"setMaximumFractionDigits\",\"goog.i18n.NumberFormat.prototype.setMaximumFractionDigits\",\"max\",\"getMaximumFractionDigits\",\"goog.i18n.NumberFormat.prototype.getMaximumFractionDigits\",\"setSignificantDigits\",\"goog.i18n.NumberFormat.prototype.setSignificantDigits\",\"number\",\"getSignificantDigits\",\"goog.i18n.NumberFormat.prototype.getSignificantDigits\",\"setShowTrailingZeros\",\"goog.i18n.NumberFormat.prototype.setShowTrailingZeros\",\"showTrailingZeros\",\"setBaseFormatting\",\"goog.i18n.NumberFormat.prototype.setBaseFormatting\",\"baseFormattingNumber\",\"asserts\",\"assert\",\"isNull\",\"isFinite\",\"getBaseFormatting\",\"goog.i18n.NumberFormat.prototype.getBaseFormatting\",\"goog.i18n.NumberFormat.prototype.applyPattern_\",\"replace\",\"pos\",\"parseAffix_\",\"trunkStart\",\"parseTrunk_\",\"trunkLen\",\"length\",\"charAt\",\"PATTERN_SEPARATOR_\",\"goog.i18n.NumberFormat.prototype.applyStandardPattern_\",\"patternType\",\"DECIMAL_PATTERN\",\"SCIENTIFIC_PATTERN\",\"PERCENT_PATTERN\",\"currency\",\"adjustPrecision\",\"CURRENCY_PATTERN\",\"applyCompactStyle_\",\"goog.i18n.NumberFormat.prototype.applyCompactStyle_\",\"style\",\"parse\",\"goog.i18n.NumberFormat.prototype.parse\",\"text\",\"opt_pos\",\"ret\",\"NaN\",\"gotPositive\",\"indexOf\",\"gotNegative\",\"INFINITY\",\"Infinity\",\"parseNumber_\",\"goog.i18n.NumberFormat.prototype.parseNumber_\",\"sawDecimal\",\"sawExponent\",\"sawDigit\",\"exponentPos\",\"scale\",\"decimal\",\"DECIMAL_SEP\",\"grouping\",\"GROUP_SEP\",\"exponentChar\",\"EXP_SYMBOL\",\"normalizedText\",\"ch\",\"digit\",\"getDigit_\",\"PERMILL\",\"parseFloat\",\"format\",\"goog.i18n.NumberFormat.prototype.format\",\"isNaN\",\"NAN\",\"parts\",\"unit\",\"getUnitAfterRounding_\",\"decimalShift_\",\"divisorBase\",\"push\",\"prefix\",\"isNegative\",\"subformatExponential_\",\"subformatFixed_\",\"suffix\",\"join\",\"roundNumber_\",\"goog.i18n.NumberFormat.prototype.roundNumber_\",\"shift\",\"shiftedNumber\",\"roundToSignificantDigits_\",\"Math\",\"round\",\"intValue\",\"fracValue\",\"floor\",\"formatNumberGroupingRepeatingDigitsParts_\",\"goog.i18n.NumberFormat.prototype.formatNumberGroupingRepeatingDigitsParts_\",\"zeroCode\",\"intPart\",\"groupingArray\",\"repeatedDigitLen\",\"nonRepeatedGroupCompleteCount\",\"currentGroupSizeIndex\",\"currentGroupSize\",\"digitLen\",\"i\",\"String\",\"fromCharCode\",\"Number\",\"repeatedDigitIndex\",\"formatNumberGroupingNonRepeatingDigitsParts_\",\"goog.i18n.NumberFormat.prototype.formatNumberGroupingNonRepeatingDigitsParts_\",\"digitLenLeft\",\"rightToLeftParts\",\"rightDigitIndex\",\"apply\",\"reverse\",\"goog.i18n.NumberFormat.prototype.subformatFixed_\",\"minIntDigits\",\"rounded\",\"numIntDigits\",\"intLog10_\",\"fractionPresent\",\"minimumFractionDigits\",\"translatableInt\",\"ZERO_DIGIT\",\"charCodeAt\",\"nonRepeatedGroupCount\",\"j\",\"fracPart\",\"fracPartSplit\",\"split\",\"floatFrac\",\"exp\",\"parseInt\",\"string\",\"repeat\",\"zeroesToAdd\",\"fracLen\",\"addExponentPart_\",\"goog.i18n.NumberFormat.prototype.addExponentPart_\",\"exponent\",\"PLUS_SIGN\",\"exponentDigits\",\"zeroChar\",\"getMantissa_\",\"goog.i18n.NumberFormat.prototype.getMantissa_\",\"value\",\"goog.i18n.NumberFormat.prototype.subformatExponential_\",\"math\",\"safeFloor\",\"log\",\"remainder\",\"goog.i18n.NumberFormat.prototype.getDigit_\",\"code\",\"PATTERN_ZERO_DIGIT_\",\"PATTERN_GROUPING_SEPARATOR_\",\"PATTERN_DECIMAL_SEPARATOR_\",\"PATTERN_PER_MILLE_\",\"PATTERN_PERCENT_\",\"PATTERN_DIGIT_\",\"PATTERN_EXPONENT_\",\"PATTERN_PLUS_\",\"PATTERN_CURRENCY_SIGN_\",\"QUOTE_\",\"goog.i18n.NumberFormat.prototype.parseAffix_\",\"affix\",\"inQuote\",\"len\",\"getLocalCurrencySign\",\"getGlobalCurrencySign\",\"getPortableCurrencySign\",\"goog.i18n.NumberFormat.prototype.parseTrunk_\",\"decimalPos\",\"digitLeftCount\",\"zeroDigitCount\",\"digitRightCount\",\"groupingCount\",\"loop\",\"n\",\"totalDigits\",\"effectiveDecimalPos\",\"CompactNumberUnit\",\"NULL_UNIT_\",\"getUnitFor_\",\"goog.i18n.NumberFormat.prototype.getUnitFor_\",\"base\",\"plurality\",\"table\",\"CompactNumberFormatSymbols\",\"COMPACT_DECIMAL_SHORT_PATTERN\",\"COMPACT_DECIMAL_LONG_PATTERN\",\"isDefAndNotNull\",\"patterns\",\"previousNonNullBase\",\"exec\",\"goog.i18n.NumberFormat.prototype.getUnitAfterRounding_\",\"formattingNumber\",\"pluralityNumber\",\"abs\",\"initialPlurality\",\"pluralForm_\",\"initialDivisor\",\"pluralityAttempt\",\"pluralityRounded\",\"formattingAttempt\",\"formattingRounded\",\"finalPlurality\",\"goog.i18n.NumberFormat.prototype.intLog10_\",\"goog.i18n.NumberFormat.decimalShift_\",\"digitCount\",\"numParts\",\"magnitude\",\"decimalRound_\",\"goog.i18n.NumberFormat.decimalRound_\",\"decimalCount\",\"goog.i18n.NumberFormat.prototype.roundToSignificantDigits_\",\"significantDigits\",\"digits\",\"goog.i18n.NumberFormat.prototype.pluralForm_\",\"quantity\",\"isCurrencyCodeBeforeValue\",\"goog.i18n.NumberFormat.prototype.isCurrencyCodeBeforeValue\",\"posCurrSymbol\",\"posPound\",\"posZero\",\"posCurrValue\",\"MAX_VALUE\"]\n}\n"]