["^ ","~:output",["^ ","~:js","goog.provide('zprint.finish');\ngoog.require('cljs.core');\ngoog.require('clojure.string');\ngoog.require('zprint.ansi');\ngoog.require('zprint.focus');\nzprint.finish.no_style_map = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"f\",\"f\",-1597136552),(function (p1__49142_SHARP_){\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__49142_SHARP_,new cljs.core.Keyword(null,\"none\",\"none\",1333468478))){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"reverse\",\"reverse\",-888455266)], null),p1__49142_SHARP_);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"reverse\",\"reverse\",-888455266)], null);\n}\n}),new cljs.core.Keyword(null,\"b\",\"b\",1482224470),cljs.core.identity,new cljs.core.Keyword(null,\"c\",\"c\",-1763192079),cljs.core.identity], null);\n/**\n * Is n within the closed range of low to high?\n */\nzprint.finish.within_QMARK_ = (function zprint$finish$within_QMARK_(n,p__49145){\nvar vec__49146 = p__49145;\nvar low = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49146,(0),null);\nvar high = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49146,(1),null);\nreturn (((n >= low)) && ((n <= high)));\n});\n/**\n * Is n within any of the the closed range of low to high?\n */\nzprint.finish.within_vec_QMARK_ = (function zprint$finish$within_vec_QMARK_(n,low_high_vec){\nreturn cljs.core.some(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.finish.within_QMARK_,n),low_high_vec);\n});\n/**\n * Ignore any foreground/background designation, and use the\n *   focus and the color to figure out a style.  Intimately \n *   associated with build-styles.\n *   You don't have to have a color, but you do need a ground.\n *   If the ground is :c, it is used, otherwise the ground is\n *   determined from the focus.  In focus gets :f, otherwise :b.\n *   If you don't have a color, the style you get\n *   is the same as the key for the ground you get from the\n *   focus.  If you don't have a focus, you get the background.\n */\nzprint.finish.ground_color_to_style = (function zprint$finish$ground_color_to_style(p__49167,s,color,element,idx){\nvar map__49168 = p__49167;\nvar map__49168__$1 = (((((!((map__49168 == null))))?(((((map__49168.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__49168.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__49168):map__49168);\nvar style_map = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49168__$1,new cljs.core.Keyword(null,\"style-map\",\"style-map\",1488693527));\nvar focus = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49168__$1,new cljs.core.Keyword(null,\"focus\",\"focus\",234677911));\nvar select = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49168__$1,new cljs.core.Keyword(null,\"select\",\"select\",1147833503));\nvar output_QMARK_ = (cljs.core.truth_(select)?zprint.finish.within_vec_QMARK_(idx,select):true);\nif(cljs.core.truth_(output_QMARK_)){\nvar G__49173 = (function (){var or__4131__auto__ = color;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"none\",\"none\",1333468478);\n}\n})();\nvar fexpr__49172 = (function (){var G__49177 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(element,new cljs.core.Keyword(null,\"cursor-element\",\"cursor-element\",-616791907)))?(function (){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"cursor-element:\",s], 0));\n\nreturn new cljs.core.Keyword(null,\"c\",\"c\",-1763192079);\n})()\n:(cljs.core.truth_((function (){var and__4120__auto__ = focus;\nif(cljs.core.truth_(and__4120__auto__)){\nreturn ((zprint.finish.within_QMARK_(idx,focus)) && (cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(element,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))));\n} else {\nreturn and__4120__auto__;\n}\n})())?new cljs.core.Keyword(null,\"f\",\"f\",-1597136552):new cljs.core.Keyword(null,\"b\",\"b\",1482224470)));\nreturn (style_map.cljs$core$IFn$_invoke$arity$1 ? style_map.cljs$core$IFn$_invoke$arity$1(G__49177) : style_map.call(null,G__49177));\n})();\nreturn (fexpr__49172.cljs$core$IFn$_invoke$arity$1 ? fexpr__49172.cljs$core$IFn$_invoke$arity$1(G__49173) : fexpr__49172.call(null,G__49173));\n} else {\nreturn null;\n}\n});\n/**\n * Given [string :style <start>] turn it into\n *   [string :style <start> <length>]\n */\nzprint.finish.add_length = (function zprint$finish$add_length(p__49180){\nvar vec__49181 = p__49180;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49181,(0),null);\nvar style = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49181,(1),null);\nvar start = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49181,(2),null);\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,style,start,cljs.core.count(s)], null);\n});\n/**\n * Take an index and a [string :color element] and produce a\n *   [string :style element] with the correct elements (i.e., the\n *   elements with the correct idx) having a different \n *   background for focus output. The ctx is a map which\n *   must have a :style-map and may have a :focus.  The\n *   :focus is a two element vector of start and end elements\n *   which are in focus.\n */\nzprint.finish.gc_vec_to_style_vec = (function zprint$finish$gc_vec_to_style_vec(ctx,idx,p__49189){\nvar vec__49190 = p__49189;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49190,(0),null);\nvar keyword_color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49190,(1),null);\nvar element = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49190,(2),null);\nvar style = zprint.finish.ground_color_to_style(ctx,s,keyword_color,element,idx);\nif(cljs.core.truth_(style)){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"none\",\"none\",1333468478)))?style:null),element], null);\n} else {\nreturn null;\n}\n});\n/**\n * Take a vector of any length, and trim it to be\n *   only n elements in length.\n */\nzprint.finish.trim_vec = (function zprint$finish$trim_vec(n,v){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.take.cljs$core$IFn$_invoke$arity$2(n,v));\n});\n/**\n * Take an ssv element which is presumably an indent, and do 1/2\n *   of it.  If the argument is nil, do a newline with no indent.\n */\nzprint.finish.elide_indent = (function zprint$finish$elide_indent(ssv_element){\nif(cljs.core.truth_(ssv_element)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(\"\\n\",clojure.string.replace(cljs.core.first(ssv_element),\" \",\"\"))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.str,\"\\n\",cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(((cljs.core.count(cljs.core.first(ssv_element)) - (1)) / (1)),\" \")),new cljs.core.Keyword(null,\"none\",\"none\",1333468478)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478)], null);\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478)], null);\n}\n});\n/**\n * Replace all sequences of nil in the sequence with elide\n */\nzprint.finish.replace_nil_seq = (function zprint$finish$replace_nil_seq(ctx,ssv_in,elide){\nvar last_element = new cljs.core.Keyword(null,\"last-element\",\"last-element\",-1161021771).cljs$core$IFn$_invoke$arity$1(ctx);\nvar elide__$1 = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(elide),cljs.core.second(last_element),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(last_element,(2))], null);\nvar ssv = ssv_in;\nvar doing_nil_QMARK_ = false;\nvar last_elide = null;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.empty_QMARK_(ssv)){\nif(doing_nil_QMARK_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,zprint.finish.gc_vec_to_style_vec(ctx,(0),(function (){var or__4131__auto__ = last_elide;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nreturn zprint.finish.elide_indent(null);\n}\n})())),zprint.finish.gc_vec_to_style_vec(ctx,(0),elide__$1)),zprint.finish.gc_vec_to_style_vec(ctx,(0),new cljs.core.Keyword(null,\"last-element\",\"last-element\",-1161021771).cljs$core$IFn$_invoke$arity$1(ctx)));\n} else {\nreturn out;\n}\n} else {\nvar this_ssv = cljs.core.first(ssv);\nvar this_elide = ((((doing_nil_QMARK_) && ((!((this_ssv == null))))))?zprint.finish.elide_indent(this_ssv):null);\nvar G__49666 = cljs.core.next(ssv);\nvar G__49667 = (this_ssv == null);\nvar G__49668 = (cljs.core.truth_(this_elide)?this_elide:last_elide);\nvar G__49669 = ((((doing_nil_QMARK_) && ((this_ssv == null))))?out:((((doing_nil_QMARK_) && ((!((this_ssv == null))))))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,zprint.finish.gc_vec_to_style_vec(ctx,(0),this_elide)),zprint.finish.gc_vec_to_style_vec(ctx,(0),elide__$1)),this_ssv):(((this_ssv == null))?out:cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,this_ssv)\n)));\nssv = G__49666;\ndoing_nil_QMARK_ = G__49667;\nlast_elide = G__49668;\nout = G__49669;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Given a cvec, generate an index vector which can be input to map\n *   and will make map work like map-indexed -- unless there are\n *   :comment-wrap elements, in which case the :comment-wrap element\n *   will have the same element idx as the previous :comment element.\n */\nzprint.finish.index_vec = (function zprint$finish$index_vec(cvec){\nvar remaining_cvec = cvec;\nvar idx = (0);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(remaining_cvec)){\nreturn out;\n} else {\nvar vec__49262 = cljs.core.first(remaining_cvec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49262,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49262,(1),null);\nvar element_type = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49262,(2),null);\nvar new_idx = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(cljs.core.first(remaining_cvec),(2)),new cljs.core.Keyword(null,\"comment-wrap\",\"comment-wrap\",720664128)))?idx:(idx + (1)));\nvar G__49671 = cljs.core.next(remaining_cvec);\nvar G__49672 = new_idx;\nvar G__49673 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_idx);\nremaining_cvec = G__49671;\nidx = G__49672;\nout = G__49673;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Take a [[string :color <anything>] \n *         [string :color <anything>] ...] input.\n *   The focus is a vector of [start-focus end-focus] which are the \n *   inclusive values for the focus.  The end is inclusive because it \n *   gets a bit dicey if it was 'beyond', since how much beyond would \n *   be interesting given the amount of whitespace in the input.\n *   Not clear at this point just what the counts in the focus-vec count,\n *   possibly things with <anything> == :element, possibly just any\n *   [string color <anything>] vector.\n *   From this, build of: [[string :style] [string :style] ...], where\n *   :style might be a color, like :blue or :none, or it might be a \n *   java-text-pane style (which would have a color encoded in it).  This\n *   is based on the :style-map in the ctx map. Note that this :style-map\n *   doesn't have any relation to the :style-map in the options map.\n */\nzprint.finish.cvec_to_style_vec = (function zprint$finish$cvec_to_style_vec(var_args){\nvar G__49283 = arguments.length;\nswitch (G__49283) {\ncase 4:\nreturn zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 2:\nreturn zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$4 = (function (ctx,cvec,focus_vec,select_vec){\nvar ctx__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(ctx,new cljs.core.Keyword(null,\"last-element\",\"last-element\",-1161021771),cljs.core.last(cvec));\nvar str_style_vec_w_nil = cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.finish.gc_vec_to_style_vec,cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(ctx__$1,new cljs.core.Keyword(null,\"focus\",\"focus\",234677911),focus_vec,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"select\",\"select\",1147833503),select_vec], 0))),cvec);\nvar count_w_nil = cljs.core.count(str_style_vec_w_nil);\nvar str_style_vec = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,str_style_vec_w_nil);\nvar elide_vec = (cljs.core.truth_(new cljs.core.Keyword(null,\"elide\",\"elide\",-1239101386).cljs$core$IFn$_invoke$arity$1(ctx__$1))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"elide\",\"elide\",-1239101386).cljs$core$IFn$_invoke$arity$1(ctx__$1),new cljs.core.Keyword(null,\"none\",\"none\",1333468478)], null):null);\nvar str_style_vec__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(count_w_nil,cljs.core.count(str_style_vec)))?str_style_vec:(cljs.core.truth_(elide_vec)?zprint.finish.replace_nil_seq(ctx__$1,str_style_vec_w_nil,elide_vec):str_style_vec));\nreturn str_style_vec__$1;\n});\n\nzprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$2 = (function (ctx,cvec){\nreturn zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$3(ctx,cvec,null);\n});\n\nzprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$3 = (function (ctx,cvec,focus_vec){\nreturn zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$4(ctx,cvec,focus_vec,null);\n});\n\nzprint.finish.cvec_to_style_vec.cljs$lang$maxFixedArity = 4;\n\n/**\n * Take a [[string :style] [string :style] ...] vector and\n *   build a list of: [[string :style <start> <length>] \n *                  [string :style <start> <length>]...]\n *   from it.  This will compress strings which have the same style.\n */\nzprint.finish.compress_style = (function zprint$finish$compress_style(var_args){\nvar G__49308 = arguments.length;\nswitch (G__49308) {\ncase 2:\nreturn zprint.finish.compress_style.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn zprint.finish.compress_style.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.finish.compress_style.cljs$core$IFn$_invoke$arity$2 = (function (str_style_vec,initial_pos){\nvar ss_vec = str_style_vec;\nvar current = null;\nvar pos = initial_pos;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nvar ss = cljs.core.first(ss_vec);\nif(cljs.core.not(ss)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,zprint.finish.add_length(current));\n} else {\nvar same_style_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.second(current),cljs.core.second(ss));\nvar G__49686 = cljs.core.next(ss_vec);\nvar G__49687 = ((same_style_QMARK_)?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(current)),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(ss))].join(''),cljs.core.second(current),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(current,(2))], null):new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(ss),cljs.core.second(ss),pos], null));\nvar G__49688 = (pos + cljs.core.count(cljs.core.first(ss)));\nvar G__49689 = ((((same_style_QMARK_) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(initial_pos,pos))))?out:cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,zprint.finish.add_length(current)));\nss_vec = G__49686;\ncurrent = G__49687;\npos = G__49688;\nout = G__49689;\ncontinue;\n}\nbreak;\n}\n});\n\nzprint.finish.compress_style.cljs$core$IFn$_invoke$arity$1 = (function (str_style_vec){\nreturn zprint.finish.compress_style.cljs$core$IFn$_invoke$arity$2(str_style_vec,(0));\n});\n\nzprint.finish.compress_style.cljs$lang$maxFixedArity = 2;\n\n/**\n * Take a [[string :color <anything>] \n *         [string :color <anything>] ...] as input.\n *   and a focus-vec and, possibly, a non-empty cursor-vec.  If\n *   there is a cursor-vec, replace the focus-vec items with a cursor\n *   vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n *   else just return with no changes\n */\nzprint.finish.replace_focus_w_cursor = (function zprint$finish$replace_focus_w_cursor(gcw_vec,p__49321,cursor_vec){\nvar vec__49322 = p__49321;\nvar focus_start = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49322,(0),null);\nvar focus_end = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49322,(1),null);\nvar focus_vec = vec__49322;\nif(cljs.core.empty_QMARK_(cursor_vec)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [focus_vec,gcw_vec], null);\n} else {\nvar vec__49325 = cljs.core.split_at(focus_start,gcw_vec);\nvar front = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49325,(0),null);\nvar back = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49325,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [focus_start,(focus_start + (cljs.core.count(cursor_vec) - (1)))], null),cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic(front,cursor_vec,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.drop.cljs$core$IFn$_invoke$arity$2(((focus_end - focus_start) + (1)),back)], 0))], null);\n}\n});\n/**\n * Turn a [string :color] into an ansi colored string.\n */\nzprint.finish.color_style = (function zprint$finish$color_style(p__49333){\nvar vec__49334 = p__49333;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49334,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49334,(1),null);\nif((color == null)){\nreturn s;\n} else {\nif(cljs.core.coll_QMARK_(color)){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(zprint.ansi.color_str,s,color);\n} else {\nreturn zprint.ansi.color_str.cljs$core$IFn$_invoke$arity$variadic(s,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([color], 0));\n}\n}\n});\n/**\n * Use output from compress-style -- but just the [string :style] part,\n *   which since we used identity as the color map, should be just\n *   [string :color].  Produce a single string with ansi escape sequences embedded\n *   in it.\n */\nzprint.finish.color_comp_vec = (function zprint$finish$color_comp_vec(comp_vec){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(zprint.finish.color_style,comp_vec));\n});\n/**\n * Ensure one number is above a certain value.\n */\nzprint.finish.floor = (function zprint$finish$floor(f,n){\nif((n >= f)){\nreturn n;\n} else {\nreturn f;\n}\n});\nzprint.finish.fzprint_cursor = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"default-cursor\",(0)], null);\n/**\n * Take a [<string> cursor-number] pair and produce the style-vec\n *   that will display it. Allow for existing characters.\n *   This is a style-vec that map-style can use, i.e.,\n *   [[string <start> <length>] ...]\n */\nzprint.finish.cursor_style = (function zprint$finish$cursor_style(var_args){\nvar G__49348 = arguments.length;\nswitch (G__49348) {\ncase 2:\nreturn zprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn zprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\nzprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$2 = (function (p__49353,existing_count){\nvar vec__49355 = p__49353;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49355,(0),null);\nvar cursor = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49355,(1),null);\ncljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"cursor-style: s:\",s,\",cursor:\",cursor], 0));\n\nif(cljs.core.truth_(cursor)){\nvar s__$1 = (((cursor >= cljs.core.count(s)))?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(s),\" \"].join(''):s);\nvar len = cljs.core.count(s__$1);\nvar cursor__$1 = (function (){var x__4222__auto__ = zprint.finish.floor((0),(len - (1)));\nvar y__4223__auto__ = cursor;\nreturn ((x__4222__auto__ < y__4223__auto__) ? x__4222__auto__ : y__4223__auto__);\n})();\nreturn cljs.core.filterv(((function (s__$1,len,cursor__$1,vec__49355,s,cursor){\nreturn (function (p1__49343_SHARP_){\nreturn (!(cljs.core.empty_QMARK_(cljs.core.first(p1__49343_SHARP_))));\n});})(s__$1,len,cursor__$1,vec__49355,s,cursor))\n,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s__$1,(0),cursor__$1),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.get.cljs$core$IFn$_invoke$arity$2(s__$1,cursor__$1)),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"cursor-element\",\"cursor-element\",-616791907)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s__$1,(cursor__$1 + (1)),len),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null));\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [s,new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"element\",\"element\",1974019749)], null)], null);\n}\n});\n\nzprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$1 = (function (str_cursor){\nreturn zprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$2(str_cursor,(0));\n});\n\nzprint.finish.cursor_style.cljs$lang$maxFixedArity = 2;\n\n/**\n * Find out how many newlines are in a string, and where they appear.\n *   Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n *   for beginning, middle, or end (or all three).\n */\nzprint.finish.newline_vec = (function zprint$finish$newline_vec(s){\nvar nl_split = clojure.string.split.cljs$core$IFn$_invoke$arity$2([cljs.core.str.cljs$core$IFn$_invoke$arity$1(s),\" \"].join(''),/\\n/);\nvar nl_num = (cljs.core.count(nl_split) - (1));\nif((!((nl_num === (0))))){\nvar where = ((cljs.core.empty_QMARK_(cljs.core.first(nl_split)))?new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"b\",\"b\",1482224470),null], null), null):cljs.core.PersistentHashSet.EMPTY);\nvar where__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.last(nl_split),\" \"))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(where,new cljs.core.Keyword(null,\"e\",\"e\",1381269198)):where);\nvar where__$2 = (((nl_num > cljs.core.count(where__$1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(where__$1,new cljs.core.Keyword(null,\"m\",\"m\",1632677161)):where__$1);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [nl_num,where__$2], null);\n} else {\nreturn null;\n}\n});\n/**\n * Return a vector containing vectors each with the cvec elements \n *   for the start and end of each line.\n */\nzprint.finish.cvec_lines = (function zprint$finish$cvec_lines(cvec){\nvar cvec_nl = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(zprint.finish.newline_vec,cljs.core.first),cvec);\nvar idx = (0);\nvar start = (0);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.empty_QMARK_(cvec_nl)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [start,(idx - (1))], null));\n} else {\nvar vec__49487 = cljs.core.first(cvec_nl);\nvar n = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49487,(0),null);\nvar where = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49487,(1),null);\nvar cvec_element = vec__49487;\nif((cvec_element == null)){\nvar G__49738 = cljs.core.next(cvec_nl);\nvar G__49739 = (idx + (1));\nvar G__49740 = start;\nvar G__49741 = out;\ncvec_nl = G__49738;\nidx = G__49739;\nstart = G__49740;\nout = G__49741;\ncontinue;\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(n,(1));\nif(and__4120__auto__){\nreturn new cljs.core.Keyword(null,\"b\",\"b\",1482224470).cljs$core$IFn$_invoke$arity$1(where);\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar G__49743 = cljs.core.next(cvec_nl);\nvar G__49744 = (idx + (1));\nvar G__49745 = idx;\nvar G__49746 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [start,(idx - (1))], null));\ncvec_nl = G__49743;\nidx = G__49744;\nstart = G__49745;\nout = G__49746;\ncontinue;\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(n,(1));\nif(and__4120__auto__){\nreturn new cljs.core.Keyword(null,\"e\",\"e\",1381269198).cljs$core$IFn$_invoke$arity$1(where);\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar G__49747 = cljs.core.next(cvec_nl);\nvar G__49748 = (idx + (1));\nvar G__49749 = (idx + (1));\nvar G__49750 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [start,idx], null));\ncvec_nl = G__49747;\nidx = G__49748;\nstart = G__49749;\nout = G__49750;\ncontinue;\n} else {\nif(cljs.core.truth_((function (){var and__4120__auto__ = (n > (1));\nif(and__4120__auto__){\nvar and__4120__auto____$1 = new cljs.core.Keyword(null,\"b\",\"b\",1482224470).cljs$core$IFn$_invoke$arity$1(where);\nif(cljs.core.truth_(and__4120__auto____$1)){\nreturn new cljs.core.Keyword(null,\"m\",\"m\",1632677161).cljs$core$IFn$_invoke$arity$1(where);\n} else {\nreturn and__4120__auto____$1;\n}\n} else {\nreturn and__4120__auto__;\n}\n})())){\nvar G__49751 = cljs.core.next(cvec_nl);\nvar G__49752 = (idx + (1));\nvar G__49753 = idx;\nvar G__49754 = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [start,(idx - (1))], null)),cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [idx,idx], null)));\ncvec_nl = G__49751;\nidx = G__49752;\nstart = G__49753;\nout = G__49754;\ncontinue;\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"m\",\"m\",1632677161).cljs$core$IFn$_invoke$arity$1(where))){\nvar G__49757 = cljs.core.next(cvec_nl);\nvar G__49758 = (idx + (1));\nvar G__49759 = start;\nvar G__49760 = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,out,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [start,idx], null)));\ncvec_nl = G__49757;\nidx = G__49758;\nstart = G__49759;\nout = G__49760;\ncontinue;\n} else {\nreturn null;\n}\n}\n}\n}\n}\n}\nbreak;\n}\n});\n/**\n * Given a cvec index, return the line that it is in.\n */\nzprint.finish.find_line = (function zprint$finish$find_line(lines,idx){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__49495_SHARP_,p2__49494_SHARP_){\nif(zprint.finish.within_QMARK_(idx,p2__49494_SHARP_)){\nreturn cljs.core.reduced(p1__49495_SHARP_);\n} else {\nreturn (p1__49495_SHARP_ + (1));\n}\n}),(0),lines);\n});\n/**\n * Given a cvec and a focus-vec, and the number of line before and after\n *   the focus, output a vector of vectors of cvec indicies that cover the \n *   desired lines. [[start end] [start end] ...]\n */\nzprint.finish.surround_focus = (function zprint$finish$surround_focus(lines_to_cvec,p__49498,p__49499){\nvar vec__49501 = p__49498;\nvar focus_begin = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49501,(0),null);\nvar focus_end = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49501,(1),null);\nvar vec__49504 = p__49499;\nvar before = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49504,(0),null);\nvar after = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49504,(1),null);\nvar line_count = cljs.core.count(lines_to_cvec);\nvar focus_begin_line = zprint.finish.find_line(lines_to_cvec,focus_begin);\nvar focus_end_line = zprint.finish.find_line(lines_to_cvec,focus_end);\nvar before_line = (focus_begin_line - before);\nvar before_line__$1 = (((before_line > (0)))?before_line:(0));\nvar after_line = (focus_end_line + after);\nvar after_line__$1 = (((after_line >= line_count))?(line_count - (1)):after_line);\nvar surround_vec = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(lines_to_cvec,before_line__$1)),cljs.core.second(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(lines_to_cvec,after_line__$1))], null);\nreturn surround_vec;\n});\n/**\n * If given a single integer, return the range from lines.  If given\n *   a range of lines, return the beginning of the first line and the end\n *   of the last line.\n */\nzprint.finish.find_range = (function zprint$finish$find_range(lines,line_selector){\nif(typeof line_selector === 'number'){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(lines,line_selector);\n} else {\nif(cljs.core.vector_QMARK_(line_selector)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(lines,cljs.core.first(line_selector))),cljs.core.second(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(lines,cljs.core.second(line_selector)))], null);\n} else {\nthrow (new Error([\"Line selector '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(line_selector),\"' must be a number or a vector!\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(line_selector)].join('')));\n\n}\n}\n});\n/**\n * line-vec is a vector of individual lines, or two-vecs of\n *   line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n *   ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n *   which maps lines onto cvec ranges.\n */\nzprint.finish.select_lines = (function zprint$finish$select_lines(lines_to_cvec,line_vec){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.finish.find_range,lines_to_cvec),line_vec);\n});\n/**\n * Take the current cvec and any focus-vec and the options map,\n *   and figure out a set of cvecs to use.  Don't generate lines\n *   array unless we need to.\n */\nzprint.finish.handle_lines = (function zprint$finish$handle_lines(p__49513,cvec,focus_vec){\nvar map__49516 = p__49513;\nvar map__49516__$1 = (((((!((map__49516 == null))))?(((((map__49516.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__49516.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__49516):map__49516);\nvar options = map__49516__$1;\nvar map__49517 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49516__$1,new cljs.core.Keyword(null,\"output\",\"output\",-1105869043));\nvar map__49517__$1 = (((((!((map__49517 == null))))?(((((map__49517.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__49517.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__49517):map__49517);\nvar focus = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49517__$1,new cljs.core.Keyword(null,\"focus\",\"focus\",234677911));\nvar lines = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49517__$1,new cljs.core.Keyword(null,\"lines\",\"lines\",-700165781));\nvar paths = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49517__$1,new cljs.core.Keyword(null,\"paths\",\"paths\",-1807389588));\nif(cljs.core.truth_((function (){var or__4131__auto__ = lines;\nif(cljs.core.truth_(or__4131__auto__)){\nreturn or__4131__auto__;\n} else {\nvar or__4131__auto____$1 = paths;\nif(cljs.core.truth_(or__4131__auto____$1)){\nreturn or__4131__auto____$1;\n} else {\nreturn new cljs.core.Keyword(null,\"surround\",\"surround\",2016177296).cljs$core$IFn$_invoke$arity$1(focus);\n}\n}\n})())){\nvar lines_to_cvec = zprint.finish.cvec_lines(cvec);\nvar surround = new cljs.core.Keyword(null,\"surround\",\"surround\",2016177296).cljs$core$IFn$_invoke$arity$1(focus);\nvar cvec_ranges = (cljs.core.truth_(lines)?zprint.finish.select_lines(lines_to_cvec,lines):cljs.core.PersistentVector.EMPTY);\nvar cvec_ranges__$1 = (cljs.core.truth_(surround)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cvec_ranges,zprint.finish.surround_focus(lines_to_cvec,focus_vec,surround)):cvec_ranges);\nvar path_vecs = (cljs.core.truth_(paths)?cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.focus.range_ssv,cvec),paths):null);\nvar path_vecs__$1 = cljs.core.map.cljs$core$IFn$_invoke$arity$2(((function (lines_to_cvec,surround,cvec_ranges,cvec_ranges__$1,path_vecs,map__49516,map__49516__$1,options,map__49517,map__49517__$1,focus,lines,paths){\nreturn (function (p1__49512_SHARP_){\nreturn zprint.finish.surround_focus(lines_to_cvec,p1__49512_SHARP_,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(0),(0)], null));\n});})(lines_to_cvec,surround,cvec_ranges,cvec_ranges__$1,path_vecs,map__49516,map__49516__$1,options,map__49517,map__49517__$1,focus,lines,paths))\n,path_vecs);\nvar cvec_ranges__$2 = (cljs.core.truth_(path_vecs__$1)?cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cvec_ranges__$1,path_vecs__$1):cvec_ranges__$1);\nif(cljs.core.empty_QMARK_(cvec_ranges__$2)){\nreturn null;\n} else {\nreturn cvec_ranges__$2;\n}\n} else {\nreturn null;\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/finish.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",27,"~:no-doc",true],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$create-react-class","~$module$node_modules$create_react_class$index","~$react-dom","~$module$node_modules$react_dom$index","~$react-flip-move","~$module$node_modules$react_flip_move$dist$react_flip_move_cjs","~$clojure.pprint","~$cljs.pprint","~$clojure.repl","~$cljs.repl","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$zprint.finish","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.string","^V","~$s","^V","~$zprint.ansi","^W","~$zprint.focus","^X","~$cljs.core","^Y","~$goog","^Z"],"~:seen",["^O",["~:require"]],"~:uses",["^ ","~$color-str","^W","~$type-ssv","^X","~$range-ssv","^X"],"~:require-macros",["^ ","^Y","^Y"],"~:form",["~#list",["~$ns","^Q",["^17",["^10",["^V","~:as","~$s"],["^W","~:refer",["^12"]],["^X","^1:",["^13","^14"]]]]]],"~:flags",["^ ","^10",["^O",[]]],"~:js-deps",["^ "],"~:deps",["^Z","^Y","^V","^W","^X"]],"^S","^Q","~:resource-id",["~:shadow.build.classpath/resource","zprint/finish.cljc"],"~:compiled-at",1566016974503,"~:resource-name","zprint/finish.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.finish\n  (:require [clojure.string :as s]\n            [zprint.ansi :refer [color-str]]\n            [zprint.focus :refer [type-ssv range-ssv]]))\n\n;;\n;; # Process results from fzprint*\n;;\n\n#_(def no-style-map {:f identity, :b identity, :c identity})\n#_(def no-style-map {:f (partial conj [:reverse]), :b identity, :c identity})\n(def no-style-map\n  {:f #(if (not= %1 :none) (conj [:reverse] %1) [:reverse]),\n   :b identity,\n   :c identity})\n\n(defn within?\n  \"Is n within the closed range of low to high?\"\n  [n [low high]]\n  (and (>= n low) (<= n high)))\n\n(defn within-vec?\n  \"Is n within any of the the closed range of low to high?\"\n  [n low-high-vec]\n  (some (partial within? n) low-high-vec))\n\n(defn ground-color-to-style\n  \"Ignore any foreground/background designation, and use the\n  focus and the color to figure out a style.  Intimately \n  associated with build-styles.\n  You don't have to have a color, but you do need a ground.\n  If the ground is :c, it is used, otherwise the ground is\n  determined from the focus.  In focus gets :f, otherwise :b.\n  If you don't have a color, the style you get\n  is the same as the key for the ground you get from the\n  focus.  If you don't have a focus, you get the background.\"\n  [{:keys [style-map focus select]} s color element idx]\n  (let [output? (if select (within-vec? idx select) true)]\n    (when output?\n      ((style-map (if (= element :cursor-element)\n                    (do (println \"cursor-element:\" s) :c)\n                    #_(if (or (not focus) (within? idx focus)) :f :b)\n                    (if\n                      ; this is the right solution\n                      (and focus (within? idx focus) (not= element :indent))\n                      ;(and focus (within? idx focus))\n                      ; this is the hack solution\n                      ;(not (clojure.string/starts-with? s \"\\n\"))\n                      :f\n                      :b)))\n        (or color :none)))))\n\n(defn add-length\n  \"Given [string :style <start>] turn it into\n  [string :style <start> <length>]\"\n  [[s style start]]\n  [s style start (count s)])\n\n(defn gc-vec-to-style-vec\n  \"Take an index and a [string :color element] and produce a\n  [string :style element] with the correct elements (i.e., the\n  elements with the correct idx) having a different \n  background for focus output. The ctx is a map which\n  must have a :style-map and may have a :focus.  The\n  :focus is a two element vector of start and end elements\n  which are in focus.\"\n  [ctx idx [s keyword-color element]]\n  (let [style (ground-color-to-style ctx s keyword-color element idx)]\n    #_(prn \"s:\" s \"keyword-color:\" keyword-color \"style:\" style)\n    (when style [s (when (not= style :none) style) element])))\n\n(defn trim-vec\n  \"Take a vector of any length, and trim it to be\n  only n elements in length.\"\n  [n v]\n  (into [] (take n v)))\n\n(defn elide-indent\n  \"Take an ssv element which is presumably an indent, and do 1/2\n  of it.  If the argument is nil, do a newline with no indent.\"\n  [ssv-element]\n  (if ssv-element\n    (if (= \"\\n\" (clojure.string/replace (first ssv-element) \" \" \"\"))\n      [(apply str \"\\n\" (repeat (/ (dec (count (first ssv-element))) 1) \" \"))\n       :none]\n      [\"\\n\" :none])\n    [\"\\n\" :none]))\n\n(defn replace-nil-seq\n  \"Replace all sequences of nil in the sequence with elide\"\n  [ctx ssv-in elide]\n  (let [last-element (:last-element ctx)\n        elide [(first elide) (second last-element) (nth last-element 2)]]\n    (loop [ssv ssv-in\n           doing-nil? false\n           last-elide nil\n           out []]\n      (if (empty? ssv)\n        (if doing-nil?\n          (-> out\n              (conj\n                (gc-vec-to-style-vec ctx 0 (or last-elide (elide-indent nil))))\n              (conj (gc-vec-to-style-vec ctx 0 elide))\n              (conj (gc-vec-to-style-vec ctx 0 (:last-element ctx))))\n          out)\n        (let [this-ssv (first ssv)\n              this-elide (if (and doing-nil? (not (nil? this-ssv)))\n                           (elide-indent this-ssv)\n                           nil)]\n          (recur (next ssv)\n                 (nil? this-ssv)\n                 (if this-elide this-elide last-elide)\n                 (cond (and doing-nil? (nil? this-ssv)) out\n                       (and doing-nil? (not (nil? this-ssv)))\n                         (-> out\n                             (conj (gc-vec-to-style-vec ctx 0 this-elide))\n                             (conj (gc-vec-to-style-vec ctx 0 elide))\n                             (conj this-ssv))\n                       (nil? this-ssv) out\n                       :else (conj out this-ssv))))))))\n\n; presently unused\n(defn index-vec\n  \"Given a cvec, generate an index vector which can be input to map\n  and will make map work like map-indexed -- unless there are\n  :comment-wrap elements, in which case the :comment-wrap element\n  will have the same element idx as the previous :comment element.\"\n  [cvec]\n  (loop [remaining-cvec cvec\n         idx 0\n         out []]\n    (if-not remaining-cvec\n      out\n      (let [[_ _ element-type] (first remaining-cvec)\n            new-idx (if (= (nth (first remaining-cvec) 2) :comment-wrap)\n                      idx\n                      (inc idx))]\n        (recur (next remaining-cvec) new-idx (conj out new-idx))))))\n\n(defn cvec-to-style-vec\n  \"Take a [[string :color <anything>] \n           [string :color <anything>] ...] input.\n  The focus is a vector of [start-focus end-focus] which are the \n  inclusive values for the focus.  The end is inclusive because it \n  gets a bit dicey if it was 'beyond', since how much beyond would \n  be interesting given the amount of whitespace in the input.\n  Not clear at this point just what the counts in the focus-vec count,\n  possibly things with <anything> == :element, possibly just any\n  [string color <anything>] vector.\n  From this, build of: [[string :style] [string :style] ...], where\n  :style might be a color, like :blue or :none, or it might be a \n  java-text-pane style (which would have a color encoded in it).  This\n  is based on the :style-map in the ctx map. Note that this :style-map\n  doesn't have any relation to the :style-map in the options map.\"\n  ([ctx cvec focus-vec select-vec]\n   (let [ctx (assoc ctx :last-element (last cvec))\n         str-style-vec-w-nil (map-indexed (partial gc-vec-to-style-vec\n                                                   (assoc ctx\n                                                     :focus focus-vec\n                                                     :select select-vec))\n                                          cvec)\n         #_(map (partial gc-vec-to-style-vec\n                         (assoc ctx\n                           :focus focus-vec\n                           :select select-vec))\n             (index-vec cvec)\n             cvec)\n         count-w-nil (count str-style-vec-w-nil)\n         str-style-vec (remove nil? str-style-vec-w-nil)\n         elide-vec (when (:elide ctx) [(:elide ctx) :none])\n         str-style-vec (if (= count-w-nil (count str-style-vec))\n                         str-style-vec\n                         (if elide-vec\n                           ; Replace sequences of nil with elide-vec\n                           (replace-nil-seq ctx str-style-vec-w-nil elide-vec)\n                           str-style-vec))]\n     str-style-vec))\n  ([ctx cvec] (cvec-to-style-vec ctx cvec nil))\n  ([ctx cvec focus-vec] (cvec-to-style-vec ctx cvec focus-vec nil)))\n\n(defn compress-style\n  \"Take a [[string :style] [string :style] ...] vector and\n  build a list of: [[string :style <start> <length>] \n                    [string :style <start> <length>]...]\n  from it.  This will compress strings which have the same style.\"\n  ([str-style-vec initial-pos]\n   (loop [ss-vec str-style-vec\n          current nil\n          pos initial-pos\n          out []]\n     (let [ss (first ss-vec)]\n       (if-not ss\n         (conj out (add-length current))\n         (let [same-style? (= (second current) (second ss))]\n           (recur (next ss-vec)\n                  (if same-style?\n                    [(str (first current) (first ss)) (second current)\n                     (nth current 2)]\n                    [(first ss) (second ss) pos])\n                  (+ pos (count (first ss)))\n                  (if (or same-style? (= initial-pos pos))\n                    out\n                    (conj out (add-length current)))))))))\n  ([str-style-vec] (compress-style str-style-vec 0)))\n\n;;\n;; # Focus processing\n;;\n;; This capability, not presently maintained, is why the functions\n;; are fzprint, not zprint, in zprint.clj.\n;;\n\n(defn replace-focus-w-cursor\n  \"Take a [[string :color <anything>] \n           [string :color <anything>] ...] as input.\n  and a focus-vec and, possibly, a non-empty cursor-vec.  If\n  there is a cursor-vec, replace the focus-vec items with a cursor\n  vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n  else just return with no changes\"\n  [gcw-vec [focus-start focus-end :as focus-vec] cursor-vec]\n  (if (empty? cursor-vec)\n    [focus-vec gcw-vec]\n    (let [[front back] (split-at focus-start gcw-vec)]\n      [[focus-start (+ focus-start (dec (count cursor-vec)))]\n       (concat front cursor-vec (drop (inc (- focus-end focus-start)) back))])))\n\n(defn color-style\n  \"Turn a [string :color] into an ansi colored string.\"\n  [[s color]]\n  (if (nil? color)\n    s\n    (if (coll? color) (apply color-str s color) (color-str s color))))\n\n(defn color-comp-vec\n  \"Use output from compress-style -- but just the [string :style] part,\n  which since we used identity as the color map, should be just\n  [string :color].  Produce a single string with ansi escape sequences embedded\n  in it.\"\n  [comp-vec]\n  (apply str (mapv color-style comp-vec)))\n\n\n;;\n;; # Cursor\n;;\n;; A cursor is a vector [<string> <int>], where the string\n;; is displayed and the integer is where in the string the\n;; cursor 'highlight' should be displayed\n;;\n;; Appear to be two ways to do this at present, fzprint-cursor,\n;; (which still exists, but may or may not work), and  meta-data\n;; on the sexpr which is the cursor.\n;;\n\n(defn floor\n  \"Ensure one number is above a certain value.\"\n  [f n]\n  (if (>= n f) n f))\n\n(def ^:dynamic fzprint-cursor [\"default-cursor\" 0])\n\n(defn cursor-style\n  \"Take a [<string> cursor-number] pair and produce the style-vec\n  that will display it. Allow for existing characters.\n  This is a style-vec that map-style can use, i.e.,\n  [[string <start> <length>] ...]\"\n  ([[s cursor] existing-count]\n   (prn \"cursor-style: s:\" s \",cursor:\" cursor)\n   (if cursor\n     (let [s (if (>= cursor (count s)) (str s \" \") s)\n           ;s (if (empty? s) \" \" s)\n           len (count s)\n           cursor (min (floor 0 (dec len)) cursor)]\n       (filterv #(not (empty? (first %)))\n         [[(subs s 0 cursor) :none :element]\n          [(str (get s cursor)) :none :cursor-element]\n          [(subs s (inc cursor) len) :none :element]]))\n     [[s :none :element]]))\n  ([str-cursor] (cursor-style str-cursor 0)))\n\n;;\n;; # Treat a cvec like it has lines in it\n;;\n\n(defn newline-vec\n  \"Find out how many newlines are in a string, and where they appear.\n  Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n  for beginning, middle, or end (or all three).\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when (not (zero? nl-num))\n      (let [where (if (empty? (first nl-split)) #{:b} #{})\n            where (if (= (last nl-split) \" \") (conj where :e) where)\n            where (if (> nl-num (count where)) (conj where :m) where)]\n        [nl-num where]))))\n\n(defn cvec-lines\n  \"Return a vector containing vectors each with the cvec elements \n  for the start and end of each line.\"\n  [cvec]\n  (loop [cvec-nl (map (comp newline-vec first) cvec)\n         idx 0\n         start 0\n         out []]\n    #_(if (zero? idx) (println \"cvec-nl:\" cvec-nl))\n    (if (empty? cvec-nl)\n      (conj out [start (dec idx)])\n      (let [[n where :as cvec-element] (first cvec-nl)]\n        #_(println \"idx:\" idx\n                   \"cvec-element:\" cvec-element\n                   \"start:\" start\n                   \"out:\" out)\n        (cond\n          (nil? cvec-element) (recur (next cvec-nl) (inc idx) start out)\n          (and (= n 1) (:b where))\n            (recur (next cvec-nl) (inc idx) idx (conj out [start (dec idx)]))\n          (and (= n 1) (:e where))\n            (recur (next cvec-nl) (inc idx) (inc idx) (conj out [start idx]))\n          (and (> n 1) (:b where) (:m where))\n            (recur\n              (next cvec-nl)\n              (inc idx)\n              idx\n              (apply conj (conj out [start (dec idx)]) (repeat n [idx idx])))\n          (:m where) (recur (next cvec-nl)\n                            (inc idx)\n                            start\n                            (apply conj out (repeat n [start idx]))))))))\n\n(defn find-line\n  \"Given a cvec index, return the line that it is in.\"\n  [lines idx]\n  (reduce #(if (within? idx %2) (reduced %1) (inc %1)) 0 lines))\n\n(defn surround-focus\n  \"Given a cvec and a focus-vec, and the number of line before and after\n  the focus, output a vector of vectors of cvec indicies that cover the \n  desired lines. [[start end] [start end] ...]\"\n  [lines-to-cvec [focus-begin focus-end] [before after]]\n  (let [line-count (count lines-to-cvec)\n        focus-begin-line (find-line lines-to-cvec focus-begin)\n        focus-end-line (find-line lines-to-cvec focus-end)\n        #_(println \"focus-begin-line:\" focus-begin-line\n                   \"focus-end-line:\" focus-end-line)\n        before-line (- focus-begin-line before)\n        before-line (if (pos? before-line) before-line 0)\n        after-line (+ focus-end-line after)\n        after-line (if (>= after-line line-count) (dec line-count) after-line)\n        surround-vec [(first (nth lines-to-cvec before-line))\n                      (second (nth lines-to-cvec after-line))]]\n    surround-vec))\n\n(defn find-range\n  \"If given a single integer, return the range from lines.  If given\n  a range of lines, return the beginning of the first line and the end\n  of the last line.\"\n  [lines line-selector]\n  (cond (number? line-selector) (nth lines line-selector)\n        (vector? line-selector) [(first (nth lines (first line-selector)))\n                                 (second (nth lines (second line-selector)))]\n        :else (throw (#?(:clj Exception.\n                         :cljs js/Error.)\n                      (str \"Line selector '\" line-selector\n                           \"' must be a number or a vector!\" line-selector)))))\n\n(defn select-lines\n  \"line-vec is a vector of individual lines, or two-vecs of\n  line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n  ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n  which maps lines onto cvec ranges.\"\n  [lines-to-cvec line-vec]\n  (map (partial find-range lines-to-cvec) line-vec))\n\n(defn handle-lines\n  \"Take the current cvec and any focus-vec and the options map,\n  and figure out a set of cvecs to use.  Don't generate lines\n  array unless we need to.\"\n  [{{:keys [focus lines paths]} :output, :as options} cvec focus-vec]\n  (when (or lines paths (:surround focus))\n    (let [lines-to-cvec (cvec-lines cvec)\n          surround (:surround focus)\n          #_(println \"lines:\" lines \"surround:\" surround)\n          cvec-ranges (if lines (select-lines lines-to-cvec lines) [])\n          #_(println \"cvec-ranges:\" cvec-ranges)\n          cvec-ranges (if surround\n                        (conj cvec-ranges\n                              (surround-focus lines-to-cvec focus-vec surround))\n                        cvec-ranges)\n          #_(println \"cvec-ranges:\" cvec-ranges)\n          ; Turn the paths into cvec ranges\n          path-vecs (when paths (map (partial range-ssv cvec) paths))\n          #_(println \"path-vecs:\" path-vecs)\n          ; Turn cvec ranges for the bare expressions into complete lines\n          path-vecs (map #(surround-focus lines-to-cvec % [0 0]) path-vecs)\n          #_(println \"path-vecs:\" path-vecs)\n          cvec-ranges (if path-vecs (concat cvec-ranges path-vecs) cvec-ranges)\n          #_(def cvr cvec-ranges)]\n      (if (empty? cvec-ranges) nil cvec-ranges))))","~:reader-features",["^O",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["p1__49142#","zprint.finish/no-style-map","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","p__49145","vec__49146","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","zprint.finish/within?","n","low","high","zprint.finish/within-vec?","low-high-vec","cljs.core/some","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","p__49167","map__49168","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","zprint.finish/ground-color-to-style","style-map","focus","select","s","color","element","idx","output?","G__49173","fexpr__49172","G__49177","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","and__4120__auto__","or__4131__auto__","p__49180","vec__49181","zprint.finish/add-length","style","start","cljs.core/count","p__49189","vec__49190","zprint.finish/gc-vec-to-style-vec","ctx","keyword-color","zprint.finish/trim-vec","v","cljs.core.into.cljs$core$IFn$_invoke$arity$2","cljs.core.take.cljs$core$IFn$_invoke$arity$2","zprint.finish/elide-indent","ssv-element","clojure.string/replace","cljs.core/first","cljs.core.apply.cljs$core$IFn$_invoke$arity$3","cljs.core/str","cljs.core.repeat.cljs$core$IFn$_invoke$arity$2","zprint.finish/replace-nil-seq","ssv-in","elide","last-element","cljs.core/second","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","ssv","doing-nil?","last-elide","out","cljs.core/empty?","this-ssv","this-elide","cljs.core/next","zprint.finish/index-vec","cvec","remaining-cvec","cljs.core/not","vec__49262","_","element-type","new-idx","var_args","G__49283","zprint.finish/cvec-to-style-vec","js/Error","focus-vec","select-vec","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/last","str-style-vec-w-nil","cljs.core.map_indexed.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","count-w-nil","str-style-vec","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","cljs.core/nil?","elide-vec","zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$3","zprint.finish.cvec_to_style_vec.cljs$core$IFn$_invoke$arity$4","G__49308","zprint.finish/compress-style","initial-pos","ss-vec","current","pos","ss","same-style?","zprint.finish.compress_style.cljs$core$IFn$_invoke$arity$2","p__49321","vec__49322","zprint.finish/replace-focus-w-cursor","gcw-vec","focus-start","focus-end","cursor-vec","vec__49325","front","back","cljs.core/split-at","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","p__49333","vec__49334","zprint.finish/color-style","cljs.core/coll?","zprint.ansi/color-str","zprint.ansi.color_str.cljs$core$IFn$_invoke$arity$variadic","zprint.finish/color-comp-vec","comp-vec","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","zprint.finish/floor","f","zprint.finish/fzprint-cursor","G__49348","zprint.finish/cursor-style","p__49353","vec__49355","cursor","existing-count","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","len","x__4222__auto__","y__4223__auto__","p1__49343#","cljs.core/filterv","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","str-cursor","zprint.finish.cursor_style.cljs$core$IFn$_invoke$arity$2","zprint.finish/newline-vec","nl-split","clojure.string.split.cljs$core$IFn$_invoke$arity$2","nl-num","where","zprint.finish/cvec-lines","cvec-nl","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","vec__49487","cvec-element","cljs.core/conj","zprint.finish/find-line","lines","p1__49495#","p2__49494#","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.core/reduced","p__49498","p__49499","vec__49501","vec__49504","zprint.finish/surround-focus","lines-to-cvec","focus-begin","before","after","line-count","focus-begin-line","focus-end-line","before-line","after-line","surround-vec","zprint.finish/find-range","line-selector","cljs.core/vector?","zprint.finish/select-lines","line-vec","p__49513","map__49516","map__49517","zprint.finish/handle-lines","paths","options","surround","cvec-ranges","path-vecs","zprint.focus/range-ssv","p1__49512#","cljs.core.concat.cljs$core$IFn$_invoke$arity$2"]]],"~:cache-keys",["~#cmap",[["^1?","goog/math/math.js"],[1564811506000,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^O",[]],"~:deps-syms",["^Z","~$goog.array","~$goog.asserts"]]],["^1?","goog/array/array.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^1Q"]]],["^1?","goog/debug/error.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/dom/nodetype.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/object/object.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],"~:SHADOW-TIMESTAMP",[1566006790000,1563067190000],["^1?","goog/math/long.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^1Q","~$goog.reflect"]]],["^1?","goog/string/internal.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/functions/functions.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/structs/map.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1?","goog/asserts/asserts.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1?","zprint/finish.cljc"],[1566006787000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^Y","^V","^W","^X"]]],["^1?","goog/uri/uri.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^1P","^1Q","~$goog.string","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1?","zprint/focus.cljc"],[1566006787000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^Y","^V","^W"]]],["^1?","goog/base.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",[]]],["^1?","goog/structs/structs.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^1P","~$goog.object"]]],["^1?","clojure/string.cljs"],[1563067190000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^Y","^1X","~$goog.string.StringBuffer"]]],["^1?","goog/string/string.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","~$goog.string.internal"]]],["^1?","goog/reflect/reflect.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/string/stringbuffer.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/iter/iter.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^1P","^1Q","~$goog.functions","~$goog.math"]]],["^1?","cljs/core.cljs"],[1563067190000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["~$goog.math.Long","~$goog.math.Integer","^1X","^22","^1P","~$goog.Uri","^23"]]],["^1?","goog/math/integer.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z"]]],["^1?","goog/uri/utils.js"],[1564811506000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^1P","^1Q","^1X"]]],["^1?","zprint/ansi.cljc"],[1566006787000,"^1L",["^ ","^1M",null,"^1N",["^O",[]],"^1O",["^Z","^Y","^V"]]]]],"~:clj-info",["^ ","jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/core.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/default_data_readers.clj",1532582253000,"jar:file:/Users/rberger/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader.clj",1532582253000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/env.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map.clj",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/compiler.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1531525495000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64.clj",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/tagged_literals.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/binaryage/devtools/0.9.10/devtools-0.9.10.jar!/devtools/defaults.clj",1541378006000,"jar:file:/Users/rberger/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/reader_types.clj",1532582253000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/util.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/analyzer.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/externs.clj",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/js_deps.cljc",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1563067189000,"jar:file:/Users/rberger/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/impl/errors.clj",1532582253000,"jar:file:/Users/rberger/.m2/repository/org/clojure/clojurescript/1.10.520/clojurescript-1.10.520.jar!/cljs/source_map/base64_vlq.clj",1563067190000,"jar:file:/Users/rberger/.m2/repository/org/clojure/tools.reader/1.3.0/tools.reader-1.3.0.jar!/clojure/tools/reader/impl/inspect.clj",1532582253000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/finish.cljc","^7",1,"^8",14,"^9",1,"^:",27,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L"],"^M",null,"^N",["^O",[]],"^P","^Q","^T",null,"^U",["^ ","^V","^V","~$s","^V","^W","^W","^X","^X","^Y","^Y","^Z","^Z"],"^[",["^O",["^10"]],"~:shadow/js-access-global",["^O",["Error"]],"^11",["^ ","^12","^W","^13","^X","^14","^X"],"~:defs",["^ ","~$color-comp-vec",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/finish.cljc","^7",234,"^8",7,"^9",234,"^:",21,"~:arglists",["^17",["~$quote",["^17",[["~$comp-vec"]]]]],"~:doc","Use output from compress-style -- but just the [string :style] part,\n  which since we used identity as the color map, should be just\n  [string :color].  Produce a single string with ansi escape sequences embedded\n  in it."],"^P","~$zprint.finish/color-comp-vec","^6","zprint/finish.cljc","^:",21,"~:method-params",["^17",[["^2["]]],"~:protocol-impl",null,"~:arglists-meta",["^17",[null,null]],"^8",1,"~:variadic?",false,"^7",234,"~:ret-tag","~$any","^9",234,"~:max-fixed-arity",1,"~:fn-var",true,"^2Y",["^17",["^2Z",["^17",[["^2["]]]]],"^30","Use output from compress-style -- but just the [string :style] part,\n  which since we used identity as the color map, should be just\n  [string :color].  Produce a single string with ansi escape sequences embedded\n  in it."],"~$no-style-map",["^ ","^P","~$zprint.finish/no-style-map","^6","zprint/finish.cljc","^7",12,"^8",1,"^9",12,"^:",18,"^5",["^ ","^6","zprint/finish.cljc","^7",12,"^8",6,"^9",12,"^:",18],"~:tag","~$cljs.core/IMap"],"~$floor",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",255,"^8",7,"^9",255,"^:",12,"^2Y",["^17",["^2Z",["^17",[["~$f","~$n"]]]]],"^30","Ensure one number is above a certain value."],"^P","~$zprint.finish/floor","^6","zprint/finish.cljc","^:",12,"^32",["^17",[["~$f","~$n"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",255,"^9",255,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["~$f","~$n"]]]]],"^30","Ensure one number is above a certain value."],"~$gc-vec-to-style-vec",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",59,"^8",7,"^9",59,"^:",26,"^2Y",["^17",["^2Z",["^17",[["~$ctx","~$idx",["~$s","~$keyword-color","~$element"]]]]]],"^30","Take an index and a [string :color element] and produce a\n  [string :style element] with the correct elements (i.e., the\n  elements with the correct idx) having a different \n  background for focus output. The ctx is a map which\n  must have a :style-map and may have a :focus.  The\n  :focus is a two element vector of start and end elements\n  which are in focus."],"^P","~$zprint.finish/gc-vec-to-style-vec","^6","zprint/finish.cljc","^:",26,"^32",["^17",[["^3A","^3B","~$p__49189"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",59,"^36",["^O",["~$cljs.core/IVector","~$clj-nil"]],"^9",59,"^38",3,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^3A","^3B",["~$s","^3C","^3D"]]]]]],"^30","Take an index and a [string :color element] and produce a\n  [string :style element] with the correct elements (i.e., the\n  elements with the correct idx) having a different \n  background for focus output. The ctx is a map which\n  must have a :style-map and may have a :focus.  The\n  :focus is a two element vector of start and end elements\n  which are in focus."],"~$trim-vec",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",72,"^8",7,"^9",72,"^:",15,"^2Y",["^17",["^2Z",["^17",[["~$n","~$v"]]]]],"^30","Take a vector of any length, and trim it to be\n  only n elements in length."],"^P","~$zprint.finish/trim-vec","^6","zprint/finish.cljc","^:",15,"^32",["^17",[["~$n","~$v"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",72,"^36",["^O",[null,"~$clj","^37"]],"^9",72,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["~$n","~$v"]]]]],"^30","Take a vector of any length, and trim it to be\n  only n elements in length."],"~$cvec-to-style-vec",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",140,"^8",7,"^9",140,"^:",24,"^2Y",["^17",["^2Z",["^17",[["^3A","~$cvec","~$focus-vec","~$select-vec"],["^3A","^3M"],["^3A","^3M","^3N"]]]]],"^30","Take a [[string :color <anything>] \n           [string :color <anything>] ...] input.\n  The focus is a vector of [start-focus end-focus] which are the \n  inclusive values for the focus.  The end is inclusive because it \n  gets a bit dicey if it was 'beyond', since how much beyond would \n  be interesting given the amount of whitespace in the input.\n  Not clear at this point just what the counts in the focus-vec count,\n  possibly things with <anything> == :element, possibly just any\n  [string color <anything>] vector.\n  From this, build of: [[string :style] [string :style] ...], where\n  :style might be a color, like :blue or :none, or it might be a \n  java-text-pane style (which would have a color encoded in it).  This\n  is based on the :style-map in the ctx map. Note that this :style-map\n  doesn't have any relation to the :style-map in the options map.","~:top-fn",["^ ","^35",false,"~:fixed-arity",4,"^38",4,"^32",["^17",[["^3A","^3M","^3N","^3O"],["^3A","^3M"],["^3A","^3M","^3N"]]],"^2Y",["^17",[["^3A","^3M","^3N","^3O"],["^3A","^3M"],["^3A","^3M","^3N"]]],"^34",["^17",[null,null,null]]]],"^P","~$zprint.finish/cvec-to-style-vec","^6","zprint/finish.cljc","^:",24,"^3P",["^ ","^35",false,"^3Q",4,"^38",4,"^32",["^17",[["^3A","^3M","^3N","^3O"],["^3A","^3M"],["^3A","^3M","^3N"]]],"^2Y",["^17",[["^3A","^3M","^3N","^3O"],["^3A","^3M"],["^3A","^3M","^3N"]]],"^34",["^17",[null,null,null]]],"^32",["^17",[["^3A","^3M","^3N","^3O"],["^3A","^3M"],["^3A","^3M","^3N"]]],"^33",null,"^3Q",4,"^34",["^17",[null,null,null]],"^8",1,"^35",false,"~:methods",[["^ ","^3Q",4,"^35",false,"^3<",["^O",["^3K","^3G","~$cljs.core/LazySeq"]]],["^ ","^3Q",2,"^35",false,"^3<","^37"],["^ ","^3Q",3,"^35",false,"^3<",["^O",["^3K","^3G","^3T"]]]],"^7",140,"^9",140,"^38",4,"^39",true,"^2Y",["^17",[["^3A","^3M","^3N","^3O"],["^3A","^3M"],["^3A","^3M","^3N"]]],"^30","Take a [[string :color <anything>] \n           [string :color <anything>] ...] input.\n  The focus is a vector of [start-focus end-focus] which are the \n  inclusive values for the focus.  The end is inclusive because it \n  gets a bit dicey if it was 'beyond', since how much beyond would \n  be interesting given the amount of whitespace in the input.\n  Not clear at this point just what the counts in the focus-vec count,\n  possibly things with <anything> == :element, possibly just any\n  [string color <anything>] vector.\n  From this, build of: [[string :style] [string :style] ...], where\n  :style might be a color, like :blue or :none, or it might be a \n  java-text-pane style (which would have a color encoded in it).  This\n  is based on the :style-map in the ctx map. Note that this :style-map\n  doesn't have any relation to the :style-map in the options map."],"~$replace-focus-w-cursor",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",213,"^8",7,"^9",213,"^:",29,"^2Y",["^17",["^2Z",["^17",[["~$gcw-vec",["~$focus-start","~$focus-end","^19","^3N"],"~$cursor-vec"]]]]],"^30","Take a [[string :color <anything>] \n           [string :color <anything>] ...] as input.\n  and a focus-vec and, possibly, a non-empty cursor-vec.  If\n  there is a cursor-vec, replace the focus-vec items with a cursor\n  vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n  else just return with no changes"],"^P","~$zprint.finish/replace-focus-w-cursor","^6","zprint/finish.cljc","^:",29,"^32",["^17",[["^3V","~$p__49321","^3Y"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",213,"^36","^3G","^9",213,"^38",3,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^3V",["^3W","^3X","^19","^3N"],"^3Y"]]]]],"^30","Take a [[string :color <anything>] \n           [string :color <anything>] ...] as input.\n  and a focus-vec and, possibly, a non-empty cursor-vec.  If\n  there is a cursor-vec, replace the focus-vec items with a cursor\n  vec and return a new focus-vec and gcw-vec as [focus-vec gcw-vec], \n  else just return with no changes"],"~$find-line",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",331,"^8",7,"^9",331,"^:",16,"^2Y",["^17",["^2Z",["^17",[["~$lines","^3B"]]]]],"^30","Given a cvec index, return the line that it is in."],"^P","~$zprint.finish/find-line","^6","zprint/finish.cljc","^:",16,"^32",["^17",[["^41","^3B"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",331,"^36",["^O",[null,"^37"]],"^9",331,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^41","^3B"]]]]],"^30","Given a cvec index, return the line that it is in."],"~$index-vec",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",123,"^8",7,"^9",123,"^:",16,"^2Y",["^17",["^2Z",["^17",[["^3M"]]]]],"^30","Given a cvec, generate an index vector which can be input to map\n  and will make map work like map-indexed -- unless there are\n  :comment-wrap elements, in which case the :comment-wrap element\n  will have the same element idx as the previous :comment element."],"^P","~$zprint.finish/index-vec","^6","zprint/finish.cljc","^:",16,"^32",["^17",[["^3M"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",123,"^36",["^O",["^3K","^3G"]],"^9",123,"^38",1,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^3M"]]]]],"^30","Given a cvec, generate an index vector which can be input to map\n  and will make map work like map-indexed -- unless there are\n  :comment-wrap elements, in which case the :comment-wrap element\n  will have the same element idx as the previous :comment element."],"~$handle-lines",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",375,"^8",7,"^9",375,"^:",19,"^2Y",["^17",["^2Z",["^17",[[["^1K",[["^ ","~:keys",["~$focus","^41","~$paths"]],"^0","^19","~$options"]],"^3M","^3N"]]]]],"^30","Take the current cvec and any focus-vec and the options map,\n  and figure out a set of cvecs to use.  Don't generate lines\n  array unless we need to."],"^P","~$zprint.finish/handle-lines","^6","zprint/finish.cljc","^:",19,"^32",["^17",[["~$p__49513","^3M","^3N"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",375,"^36",["^O",["^3K","^3H"]],"^9",375,"^38",3,"^39",true,"^2Y",["^17",["^2Z",["^17",[[["^1K",[["^ ","^46",["^47","^41","^48"]],"^0","^19","^49"]],"^3M","^3N"]]]]],"^30","Take the current cvec and any focus-vec and the options map,\n  and figure out a set of cvecs to use.  Don't generate lines\n  array unless we need to."],"~$cursor-style",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",262,"^8",7,"^9",262,"^:",19,"^2Y",["^17",["^2Z",["^17",[[["~$s","~$cursor"],"~$existing-count"],["~$str-cursor"]]]]],"^30","Take a [<string> cursor-number] pair and produce the style-vec\n  that will display it. Allow for existing characters.\n  This is a style-vec that map-style can use, i.e.,\n  [[string <start> <length>] ...]","^3P",["^ ","^35",false,"^3Q",2,"^38",2,"^32",["^17",[[["~$s","^4="],"^4>"],["^4?"]]],"^2Y",["^17",[[["~$s","^4="],"^4>"],["^4?"]]],"^34",["^17",[null,null]]]],"^P","~$zprint.finish/cursor-style","^6","zprint/finish.cljc","^:",19,"^3P",["^ ","^35",false,"^3Q",2,"^38",2,"^32",["^17",[[["~$s","^4="],"^4>"],["^4?"]]],"^2Y",["^17",[[["~$s","^4="],"^4>"],["^4?"]]],"^34",["^17",[null,null]]],"^32",["^17",[[["~$s","^4="],"^4>"],["^4?"]]],"^33",null,"^3Q",2,"^34",["^17",[null,null]],"^8",1,"^35",false,"^3S",[["^ ","^3Q",2,"^35",false,"^3<","^3K"],["^ ","^3Q",1,"^35",false,"^3<","^3K"]],"^7",262,"^9",262,"^38",2,"^39",true,"^2Y",["^17",[[["~$s","^4="],"^4>"],["^4?"]]],"^30","Take a [<string> cursor-number] pair and produce the style-vec\n  that will display it. Allow for existing characters.\n  This is a style-vec that map-style can use, i.e.,\n  [[string <start> <length>] ...]"],"~$within-vec?",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",22,"^8",7,"^9",22,"^:",18,"^2Y",["^17",["^2Z",["^17",[["~$n","~$low-high-vec"]]]]],"^30","Is n within any of the the closed range of low to high?"],"^P","~$zprint.finish/within-vec?","^6","zprint/finish.cljc","^:",18,"^32",["^17",[["~$n","^4B"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",22,"^36",["^O",["^37","^3H"]],"^9",22,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["~$n","^4B"]]]]],"^30","Is n within any of the the closed range of low to high?"],"~$cvec-lines",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",298,"^8",7,"^9",298,"^:",17,"^2Y",["^17",["^2Z",["^17",[["^3M"]]]]],"^30","Return a vector containing vectors each with the cvec elements \n  for the start and end of each line."],"^P","~$zprint.finish/cvec-lines","^6","zprint/finish.cljc","^:",17,"^32",["^17",[["^3M"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",298,"^36",["^O",["^3K","^3H"]],"^9",298,"^38",1,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^3M"]]]]],"^30","Return a vector containing vectors each with the cvec elements \n  for the start and end of each line."],"~$within?",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",17,"^8",7,"^9",17,"^:",14,"^2Y",["^17",["^2Z",["^17",[["~$n",["~$low","~$high"]]]]]],"^30","Is n within the closed range of low to high?"],"^P","~$zprint.finish/within?","^6","zprint/finish.cljc","^:",14,"^32",["^17",[["~$n","~$p__49145"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",17,"^36","~$boolean","^9",17,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["~$n",["^4G","^4H"]]]]]],"^30","Is n within the closed range of low to high?"],"~$surround-focus",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",336,"^8",7,"^9",336,"^:",21,"^2Y",["^17",["^2Z",["^17",[["~$lines-to-cvec",["~$focus-begin","^3X"],["~$before","~$after"]]]]]],"^30","Given a cvec and a focus-vec, and the number of line before and after\n  the focus, output a vector of vectors of cvec indicies that cover the \n  desired lines. [[start end] [start end] ...]"],"^P","~$zprint.finish/surround-focus","^6","zprint/finish.cljc","^:",21,"^32",["^17",[["^4M","~$p__49498","~$p__49499"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",336,"^36","^3G","^9",336,"^38",3,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^4M",["^4N","^3X"],["^4O","^4P"]]]]]],"^30","Given a cvec and a focus-vec, and the number of line before and after\n  the focus, output a vector of vectors of cvec indicies that cover the \n  desired lines. [[start end] [start end] ...]"],"~$fzprint-cursor",["^ ","^5",["^ ","^6","zprint/finish.cljc","^7",260,"^8",16,"^9",260,"^:",30,"~:dynamic",true],"^P","~$zprint.finish/fzprint-cursor","^6","zprint/finish.cljc","^:",30,"^8",1,"^4U",true,"^7",260,"^9",260,"^3<","^3G"],"~$color-style",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",227,"^8",7,"^9",227,"^:",18,"^2Y",["^17",["^2Z",["^17",[[["~$s","~$color"]]]]]],"^30","Turn a [string :color] into an ansi colored string."],"^P","~$zprint.finish/color-style","^6","zprint/finish.cljc","^:",18,"^32",["^17",[["~$p__49333"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",227,"^36",["^O",[null,"^37","~$string","^3H"]],"^9",227,"^38",1,"^39",true,"^2Y",["^17",["^2Z",["^17",[[["~$s","^4X"]]]]]],"^30","Turn a [string :color] into an ansi colored string."],"~$elide-indent",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",78,"^8",7,"^9",78,"^:",19,"^2Y",["^17",["^2Z",["^17",[["~$ssv-element"]]]]],"^30","Take an ssv element which is presumably an indent, and do 1/2\n  of it.  If the argument is nil, do a newline with no indent."],"^P","~$zprint.finish/elide-indent","^6","zprint/finish.cljc","^:",19,"^32",["^17",[["^51"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",78,"^36","^3G","^9",78,"^38",1,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^51"]]]]],"^30","Take an ssv element which is presumably an indent, and do 1/2\n  of it.  If the argument is nil, do a newline with no indent."],"~$add-length",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",53,"^8",7,"^9",53,"^:",17,"^2Y",["^17",["^2Z",["^17",[[["~$s","~$style","~$start"]]]]]],"^30","Given [string :style <start>] turn it into\n  [string :style <start> <length>]"],"^P","~$zprint.finish/add-length","^6","zprint/finish.cljc","^:",17,"^32",["^17",[["~$p__49180"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",53,"^36","^3G","^9",53,"^38",1,"^39",true,"^2Y",["^17",["^2Z",["^17",[[["~$s","^54","^55"]]]]]],"^30","Given [string :style <start>] turn it into\n  [string :style <start> <length>]"],"~$select-lines",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",367,"^8",7,"^9",367,"^:",19,"^2Y",["^17",["^2Z",["^17",[["^4M","~$line-vec"]]]]],"^30","line-vec is a vector of individual lines, or two-vecs of\n  line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n  ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n  which maps lines onto cvec ranges."],"^P","~$zprint.finish/select-lines","^6","zprint/finish.cljc","^:",19,"^32",["^17",[["^4M","^59"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",367,"^36","^3T","^9",367,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^4M","^59"]]]]],"^30","line-vec is a vector of individual lines, or two-vecs of\n  line ranges: [1 2 [3-5] 8 9]. Returns a vector of cvec element\n  ranges [[0 20] [45-70] ...].  lines is the return from cvec-lines,\n  which maps lines onto cvec ranges."],"~$ground-color-to-style",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",27,"^8",7,"^9",27,"^:",28,"^2Y",["^17",["^2Z",["^17",[[["^ ","^46",["~$style-map","^47","~$select"]],"~$s","^4X","^3D","^3B"]]]]],"^30","Ignore any foreground/background designation, and use the\n  focus and the color to figure out a style.  Intimately \n  associated with build-styles.\n  You don't have to have a color, but you do need a ground.\n  If the ground is :c, it is used, otherwise the ground is\n  determined from the focus.  In focus gets :f, otherwise :b.\n  If you don't have a color, the style you get\n  is the same as the key for the ground you get from the\n  focus.  If you don't have a focus, you get the background."],"^P","~$zprint.finish/ground-color-to-style","^6","zprint/finish.cljc","^:",28,"^32",["^17",[["~$p__49167","~$s","^4X","^3D","^3B"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",27,"^36",["^O",["^37","^3H"]],"^9",27,"^38",5,"^39",true,"^2Y",["^17",["^2Z",["^17",[[["^ ","^46",["^5<","^47","^5="]],"~$s","^4X","^3D","^3B"]]]]],"^30","Ignore any foreground/background designation, and use the\n  focus and the color to figure out a style.  Intimately \n  associated with build-styles.\n  You don't have to have a color, but you do need a ground.\n  If the ground is :c, it is used, otherwise the ground is\n  determined from the focus.  In focus gets :f, otherwise :b.\n  If you don't have a color, the style you get\n  is the same as the key for the ground you get from the\n  focus.  If you don't have a focus, you get the background."],"~$newline-vec",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",285,"^8",7,"^9",285,"^:",18,"^2Y",["^17",["^2Z",["^17",[["~$s"]]]]],"^30","Find out how many newlines are in a string, and where they appear.\n  Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n  for beginning, middle, or end (or all three)."],"^P","~$zprint.finish/newline-vec","^6","zprint/finish.cljc","^:",18,"^32",["^17",[["~$s"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",285,"^36",["^O",["^3G","^3H"]],"^9",285,"^38",1,"^39",true,"^2Y",["^17",["^2Z",["^17",[["~$s"]]]]],"^30","Find out how many newlines are in a string, and where they appear.\n  Returns either nil for no newlines, or a vector [<count> #{:b :m :e}]\n  for beginning, middle, or end (or all three)."],"~$compress-style",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",181,"^8",7,"^9",181,"^:",21,"^2Y",["^17",["^2Z",["^17",[["~$str-style-vec","~$initial-pos"],["^5C"]]]]],"^30","Take a [[string :style] [string :style] ...] vector and\n  build a list of: [[string :style <start> <length>] \n                    [string :style <start> <length>]...]\n  from it.  This will compress strings which have the same style.","^3P",["^ ","^35",false,"^3Q",2,"^38",2,"^32",["^17",[["^5C","^5D"],["^5C"]]],"^2Y",["^17",[["^5C","^5D"],["^5C"]]],"^34",["^17",[null,null]]]],"^P","~$zprint.finish/compress-style","^6","zprint/finish.cljc","^:",21,"^3P",["^ ","^35",false,"^3Q",2,"^38",2,"^32",["^17",[["^5C","^5D"],["^5C"]]],"^2Y",["^17",[["^5C","^5D"],["^5C"]]],"^34",["^17",[null,null]]],"^32",["^17",[["^5C","^5D"],["^5C"]]],"^33",null,"^3Q",2,"^34",["^17",[null,null]],"^8",1,"^35",false,"^3S",[["^ ","^3Q",2,"^35",false,"^3<","^3K"],["^ ","^3Q",1,"^35",false,"^3<","^3K"]],"^7",181,"^9",181,"^38",2,"^39",true,"^2Y",["^17",[["^5C","^5D"],["^5C"]]],"^30","Take a [[string :style] [string :style] ...] vector and\n  build a list of: [[string :style <start> <length>] \n                    [string :style <start> <length>]...]\n  from it.  This will compress strings which have the same style."],"~$find-range",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",354,"^8",7,"^9",354,"^:",17,"^2Y",["^17",["^2Z",["^17",[["^41","~$line-selector"]]]]],"^30","If given a single integer, return the range from lines.  If given\n  a range of lines, return the beginning of the first line and the end\n  of the last line."],"^P","~$zprint.finish/find-range","^6","zprint/finish.cljc","^:",17,"^32",["^17",[["^41","^5G"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",354,"^36",["^O",["^3G","^37","^3H"]],"^9",354,"^38",2,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^41","^5G"]]]]],"^30","If given a single integer, return the range from lines.  If given\n  a range of lines, return the beginning of the first line and the end\n  of the last line."],"~$replace-nil-seq",["^ ","^2X",null,"^5",["^ ","^6","zprint/finish.cljc","^7",89,"^8",7,"^9",89,"^:",22,"^2Y",["^17",["^2Z",["^17",[["^3A","~$ssv-in","~$elide"]]]]],"^30","Replace all sequences of nil in the sequence with elide"],"^P","~$zprint.finish/replace-nil-seq","^6","zprint/finish.cljc","^:",22,"^32",["^17",[["^3A","^5J","^5K"]]],"^33",null,"^34",["^17",[null,null]],"^8",1,"^35",false,"^7",89,"^36",["^O",["^3K","^3G"]],"^9",89,"^38",3,"^39",true,"^2Y",["^17",["^2Z",["^17",[["^3A","^5J","^5K"]]]]],"^30","Replace all sequences of nil in the sequence with elide"]],"^15",["^ ","^Y","^Y"],"~:cljs.analyzer/constants",["^ ","^[",["^O",["~:comment-wrap","~:indent","~:element","~:else","~:m","~:lines","~:paths","^0","~:e","~:surround","~:c","~:last-element","~:elide","~:b","~:style-map","~:focus","~:f","~:cursor-element","~:none","~:reverse","~:select"]],"~:order",["~:f","~:b","~:c","^5Z","^5[","^5W","^5X","^60","^5Y","^5O","^5U","^5Q","^5N","^5V","^5P","~:e","~:m","^0","^5R","^5S","^5T"]],"^1;",["^ ","^10",["^O",[]]],"^1<",["^ "],"^1=",["^Z","^Y","^V","^W","^X"]],"^S","^Q","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1K",[["^64","~:static-fns"],true,["^64","~:elide-asserts"],false,["^64","~:optimize-constants"],null,["^64","^1B"],null,["^64","~:external-config"],null,["^64","~:tooling-config"],null,["^64","~:emit-constants"],null,["^64","~:load-tests"],null,["^64","~:infer-externs"],true,["^64","^1D"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^64","~:fn-invoke-direct"],null,["^64","~:source-map"],"/dev/null"]]]